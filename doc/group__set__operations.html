<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>thrust: Set Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">thrust
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Set Operations<div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadbd3cc430040aef1ead1a8885bd2bdc6"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gadbd3cc430040aef1ead1a8885bd2bdc6"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#gadbd3cc430040aef1ead1a8885bd2bdc6">thrust::set_difference</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr class="separator:gadbd3cc430040aef1ead1a8885bd2bdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf5edd558fd96eee01b6425b3909c6b4"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gacf5edd558fd96eee01b6425b3909c6b4"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#gacf5edd558fd96eee01b6425b3909c6b4">thrust::set_difference</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr class="separator:gacf5edd558fd96eee01b6425b3909c6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d866c84292ddd43342fc171f95ca652"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:ga6d866c84292ddd43342fc171f95ca652"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga6d866c84292ddd43342fc171f95ca652">thrust::set_difference</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
<tr class="separator:ga6d866c84292ddd43342fc171f95ca652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4528ff414e0292680ba412dbafdc6e1"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:gab4528ff414e0292680ba412dbafdc6e1"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#gab4528ff414e0292680ba412dbafdc6e1">thrust::set_difference</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
<tr class="separator:gab4528ff414e0292680ba412dbafdc6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e9671d6d44c7c384fa84bd4170eb431"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga7e9671d6d44c7c384fa84bd4170eb431"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">thrust::set_intersection</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr class="separator:ga7e9671d6d44c7c384fa84bd4170eb431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga939f2c87cff784afc63e39c5e5119784"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga939f2c87cff784afc63e39c5e5119784"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga939f2c87cff784afc63e39c5e5119784">thrust::set_intersection</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr class="separator:ga939f2c87cff784afc63e39c5e5119784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95576446f3a8f0302317d9ea2c9e8a74"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:ga95576446f3a8f0302317d9ea2c9e8a74"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga95576446f3a8f0302317d9ea2c9e8a74">thrust::set_intersection</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
<tr class="separator:ga95576446f3a8f0302317d9ea2c9e8a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63a7ebdaf5797f78be04febd436cd284"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:ga63a7ebdaf5797f78be04febd436cd284"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga63a7ebdaf5797f78be04febd436cd284">thrust::set_intersection</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
<tr class="separator:ga63a7ebdaf5797f78be04febd436cd284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fa1ae8ee04cadd3279288d96045b0c4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga6fa1ae8ee04cadd3279288d96045b0c4"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga6fa1ae8ee04cadd3279288d96045b0c4">thrust::set_symmetric_difference</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr class="separator:ga6fa1ae8ee04cadd3279288d96045b0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16bc72ce5444f82fca22e178b8370a98"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga16bc72ce5444f82fca22e178b8370a98"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga16bc72ce5444f82fca22e178b8370a98">thrust::set_symmetric_difference</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr class="separator:ga16bc72ce5444f82fca22e178b8370a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3999b76f6fa90b57f9b50bd69bcab8eb"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:ga3999b76f6fa90b57f9b50bd69bcab8eb"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga3999b76f6fa90b57f9b50bd69bcab8eb">thrust::set_symmetric_difference</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
<tr class="separator:ga3999b76f6fa90b57f9b50bd69bcab8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2194c9c4fe22397aff13e1c163c86446"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:ga2194c9c4fe22397aff13e1c163c86446"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga2194c9c4fe22397aff13e1c163c86446">thrust::set_symmetric_difference</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
<tr class="separator:ga2194c9c4fe22397aff13e1c163c86446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga974aed5fabc60590b7efa20464021caf"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga974aed5fabc60590b7efa20464021caf"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">thrust::set_union</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr class="separator:ga974aed5fabc60590b7efa20464021caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae9a47e263655f0e56b1a4860182d4a8"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gaae9a47e263655f0e56b1a4860182d4a8"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#gaae9a47e263655f0e56b1a4860182d4a8">thrust::set_union</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr class="separator:gaae9a47e263655f0e56b1a4860182d4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61a7f2ee79a8a7a2c61e22cb24f369f2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:ga61a7f2ee79a8a7a2c61e22cb24f369f2"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga61a7f2ee79a8a7a2c61e22cb24f369f2">thrust::set_union</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
<tr class="separator:ga61a7f2ee79a8a7a2c61e22cb24f369f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d768feeec14f067304bf66bf59aaecf"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:ga5d768feeec14f067304bf66bf59aaecf"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga5d768feeec14f067304bf66bf59aaecf">thrust::set_union</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
<tr class="separator:ga5d768feeec14f067304bf66bf59aaecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga062e76cd283cffd5391ef8254b45910a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 &gt; </td></tr>
<tr class="memitem:ga062e76cd283cffd5391ef8254b45910a"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga062e76cd283cffd5391ef8254b45910a">thrust::set_difference_by_key</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result)</td></tr>
<tr class="separator:ga062e76cd283cffd5391ef8254b45910a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ea27dd891f59cb73f6f28f8e97bfb1c"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 &gt; </td></tr>
<tr class="memitem:ga1ea27dd891f59cb73f6f28f8e97bfb1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga1ea27dd891f59cb73f6f28f8e97bfb1c">thrust::set_difference_by_key</a> (InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result)</td></tr>
<tr class="separator:ga1ea27dd891f59cb73f6f28f8e97bfb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3034549f40783b52e32a6d7f3d580c8c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:ga3034549f40783b52e32a6d7f3d580c8c"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga3034549f40783b52e32a6d7f3d580c8c">thrust::set_difference_by_key</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result, StrictWeakCompare comp)</td></tr>
<tr class="separator:ga3034549f40783b52e32a6d7f3d580c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15aeb0c36bfdfca1e1d3f87b61d6add2"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:ga15aeb0c36bfdfca1e1d3f87b61d6add2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga15aeb0c36bfdfca1e1d3f87b61d6add2">thrust::set_difference_by_key</a> (InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result, StrictWeakCompare comp)</td></tr>
<tr class="separator:ga15aeb0c36bfdfca1e1d3f87b61d6add2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9db7cdc6dc16466f46f8cdd29a4310e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename OutputIterator1 , typename OutputIterator2 &gt; </td></tr>
<tr class="memitem:gac9db7cdc6dc16466f46f8cdd29a4310e"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#gac9db7cdc6dc16466f46f8cdd29a4310e">thrust::set_intersection_by_key</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, OutputIterator1 keys_result, OutputIterator2 values_result)</td></tr>
<tr class="separator:gac9db7cdc6dc16466f46f8cdd29a4310e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77564b343a17454dfb672a2acad7f80f"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename OutputIterator1 , typename OutputIterator2 &gt; </td></tr>
<tr class="memitem:ga77564b343a17454dfb672a2acad7f80f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga77564b343a17454dfb672a2acad7f80f">thrust::set_intersection_by_key</a> (InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, OutputIterator1 keys_result, OutputIterator2 values_result)</td></tr>
<tr class="separator:ga77564b343a17454dfb672a2acad7f80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d0335a158421c13dd386942af1546eb"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename OutputIterator1 , typename OutputIterator2 , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:ga7d0335a158421c13dd386942af1546eb"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga7d0335a158421c13dd386942af1546eb">thrust::set_intersection_by_key</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, OutputIterator1 keys_result, OutputIterator2 values_result, StrictWeakCompare comp)</td></tr>
<tr class="separator:ga7d0335a158421c13dd386942af1546eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fe9305ddfc3920adfeca1edc48d84d1"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename OutputIterator1 , typename OutputIterator2 , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:ga3fe9305ddfc3920adfeca1edc48d84d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga3fe9305ddfc3920adfeca1edc48d84d1">thrust::set_intersection_by_key</a> (InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, OutputIterator1 keys_result, OutputIterator2 values_result, StrictWeakCompare comp)</td></tr>
<tr class="separator:ga3fe9305ddfc3920adfeca1edc48d84d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00e191876364d0e340765fc8f90895cd"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 &gt; </td></tr>
<tr class="memitem:ga00e191876364d0e340765fc8f90895cd"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">thrust::set_symmetric_difference_by_key</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result)</td></tr>
<tr class="separator:ga00e191876364d0e340765fc8f90895cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bb0a94b88c9c7a5ce38ee3e3fe866d2"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 &gt; </td></tr>
<tr class="memitem:ga7bb0a94b88c9c7a5ce38ee3e3fe866d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga7bb0a94b88c9c7a5ce38ee3e3fe866d2">thrust::set_symmetric_difference_by_key</a> (InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result)</td></tr>
<tr class="separator:ga7bb0a94b88c9c7a5ce38ee3e3fe866d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01f25713cfd986ab8c03da1c259da11b"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:ga01f25713cfd986ab8c03da1c259da11b"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga01f25713cfd986ab8c03da1c259da11b">thrust::set_symmetric_difference_by_key</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result, StrictWeakCompare comp)</td></tr>
<tr class="separator:ga01f25713cfd986ab8c03da1c259da11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb0747256e755a4f535e598fe245acec"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:gaeb0747256e755a4f535e598fe245acec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#gaeb0747256e755a4f535e598fe245acec">thrust::set_symmetric_difference_by_key</a> (InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result, StrictWeakCompare comp)</td></tr>
<tr class="separator:gaeb0747256e755a4f535e598fe245acec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b19cdab25f1dd1bafbe356296e7c0b8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 &gt; </td></tr>
<tr class="memitem:ga1b19cdab25f1dd1bafbe356296e7c0b8"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga1b19cdab25f1dd1bafbe356296e7c0b8">thrust::set_union_by_key</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result)</td></tr>
<tr class="separator:ga1b19cdab25f1dd1bafbe356296e7c0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b78f1cfc290b9bf0579a074729c8149"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 &gt; </td></tr>
<tr class="memitem:ga9b78f1cfc290b9bf0579a074729c8149"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga9b78f1cfc290b9bf0579a074729c8149">thrust::set_union_by_key</a> (InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result)</td></tr>
<tr class="separator:ga9b78f1cfc290b9bf0579a074729c8149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabefb2fcb73e2d1ea5efab778e174240"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:gaabefb2fcb73e2d1ea5efab778e174240"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#gaabefb2fcb73e2d1ea5efab778e174240">thrust::set_union_by_key</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result, StrictWeakCompare comp)</td></tr>
<tr class="separator:gaabefb2fcb73e2d1ea5efab778e174240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace7a92108ce79b7d43f060b46a0c776c"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:gace7a92108ce79b7d43f060b46a0c776c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#gace7a92108ce79b7d43f060b46a0c776c">thrust::set_union_by_key</a> (InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result, StrictWeakCompare comp)</td></tr>
<tr class="separator:gace7a92108ce79b7d43f060b46a0c776c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gadbd3cc430040aef1ead1a8885bd2bdc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ OutputIterator thrust::set_difference </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_difference</code> constructs a sorted range that is the set difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_difference</code> performs the "difference" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code> and not contained in <code>[first2, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, the last <code>max(m-n,0)</code> elements from <code>[first1, last1)</code> range shall be copied to the output range.</p>
<p>This version of <code>set_difference</code> compares elements using <code>operator&lt;</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_difference</code> to compute the set difference of two sets of integers sorted in ascending order using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[6] = {0, 1, 3, 4, 5, 6, 9};</div>
<div class="line"><span class="keywordtype">int</span> A2[5] = {1, 3, 5, 7, 9};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[3];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#gadbd3cc430040aef1ead1a8885bd2bdc6">thrust::set_difference</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, A1, A1 + 6, A2, A2 + 5, result);</div>
<div class="line"><span class="comment">// result is now {0, 4, 6}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/set_difference.html">http://www.sgi.com/tech/stl/set_difference.html</a> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga6fa1ae8ee04cadd3279288d96045b0c4">set_symmetric_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="gacf5edd558fd96eee01b6425b3909c6b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::set_difference </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_difference</code> constructs a sorted range that is the set difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_difference</code> performs the "difference" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code> and not contained in <code>[first2, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, the last <code>max(m-n,0)</code> elements from <code>[first1, last1)</code> range shall be copied to the output range.</p>
<p>This version of <code>set_difference</code> compares elements using <code>operator&lt;</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_difference</code> to compute the set difference of two sets of integers sorted in ascending order.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[6] = {0, 1, 3, 4, 5, 6, 9};</div>
<div class="line"><span class="keywordtype">int</span> A2[5] = {1, 3, 5, 7, 9};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[3];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#gadbd3cc430040aef1ead1a8885bd2bdc6">thrust::set_difference</a>(A1, A1 + 6, A2, A2 + 5, result);</div>
<div class="line"><span class="comment">// result is now {0, 4, 6}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/set_difference.html">http://www.sgi.com/tech/stl/set_difference.html</a> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga6fa1ae8ee04cadd3279288d96045b0c4">set_symmetric_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d866c84292ddd43342fc171f95ca652"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ OutputIterator thrust::set_difference </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_difference</code> constructs a sorted range that is the set difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_difference</code> performs the "difference" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code> and not contained in <code>[first2, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, the last <code>max(m-n,0)</code> elements from <code>[first1, last1)</code> range shall be copied to the output range.</p>
<p>This version of <code>set_difference</code> compares elements using a function object <code>comp</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>first_argument_type</code>. and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>second_argument_type</code>. and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">StrictWeakCompare</td><td>is a model of <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict Weak Ordering</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_difference</code> to compute the set difference of two sets of integers sorted in descending order using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[6] = {9, 6, 5, 4, 3, 1, 0};</div>
<div class="line"><span class="keywordtype">int</span> A2[5] = {9, 7, 5, 3, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[3];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#gadbd3cc430040aef1ead1a8885bd2bdc6">thrust::set_difference</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, A1, A1 + 6, A2, A2 + 5, result, <a class="code" href="structthrust_1_1greater.html">thrust::greater&lt;int&gt;</a>());</div>
<div class="line"><span class="comment">// result is now {6, 4, 0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/set_difference.html">http://www.sgi.com/tech/stl/set_difference.html</a> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga6fa1ae8ee04cadd3279288d96045b0c4">set_symmetric_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="gab4528ff414e0292680ba412dbafdc6e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::set_difference </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_difference</code> constructs a sorted range that is the set difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_difference</code> performs the "difference" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code> and not contained in <code>[first2, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, the last <code>max(m-n,0)</code> elements from <code>[first1, last1)</code> range shall be copied to the output range.</p>
<p>This version of <code>set_difference</code> compares elements using a function object <code>comp</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>first_argument_type</code>. and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>second_argument_type</code>. and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">StrictWeakCompare</td><td>is a model of <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict Weak Ordering</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_difference</code> to compute the set difference of two sets of integers sorted in descending order.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[6] = {9, 6, 5, 4, 3, 1, 0};</div>
<div class="line"><span class="keywordtype">int</span> A2[5] = {9, 7, 5, 3, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[3];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#gadbd3cc430040aef1ead1a8885bd2bdc6">thrust::set_difference</a>(A1, A1 + 6, A2, A2 + 5, result, <a class="code" href="structthrust_1_1greater.html">thrust::greater&lt;int&gt;</a>());</div>
<div class="line"><span class="comment">// result is now {6, 4, 0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/set_difference.html">http://www.sgi.com/tech/stl/set_difference.html</a> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga6fa1ae8ee04cadd3279288d96045b0c4">set_symmetric_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga062e76cd283cffd5391ef8254b45910a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::set_difference_by_key </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>values_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_difference_by_key</code> performs a key-value difference operation from set theory. <code>set_difference_by_key</code> constructs a sorted range that is the difference of the sorted ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.</p>
<p>In the simplest case, <code>set_difference_by_key</code> performs the "difference" operation from set theory: the keys output range contains a copy of every element that is contained in <code>[keys_first1, keys_last1)</code> and not contained in <code>[keys_first2, keys_last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys_first1, keys_last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[keys_first2, keys_last2)</code> contains <code>n</code> elements that are equivalent to them, the last <code>max(m-n,0)</code> elements from <code>[keys_first1, keys_last1)</code> range shall be copied to the output range.</p>
<p>Each time a key element is copied from <code>[keys_first1, keys_last1)</code> or <code>[keys_first2, keys_last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values_first1</code> or <code>values_first2</code>) to the values output range.</p>
<p>This version of <code>set_difference_by_key</code> compares key elements using <code>operator&lt;</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">values_first2</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the output range of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator4</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator4's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_difference_by_key</code> to compute the set difference of two sets of integers sorted in ascending order with their values using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {0, 1, 3, 4, 5, 6, 9};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = {0, 0, 0, 0, 0, 0, 0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[5] = {1, 3, 5, 7, 9};</div>
<div class="line"><span class="keywordtype">int</span> B_vals[5] = {1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[3];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[3];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end = <a class="code" href="group__set__operations.html#ga062e76cd283cffd5391ef8254b45910a">thrust::set_difference_by_key</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);</div>
<div class="line"><span class="comment">// keys_result is now {0, 4, 6}</span></div>
<div class="line"><span class="comment">// vals_result is now {0, 0, 0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__set__operations.html#ga1b19cdab25f1dd1bafbe356296e7c0b8">set_union_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#gac9db7cdc6dc16466f46f8cdd29a4310e">set_intersection_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">set_symmetric_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ea27dd891f59cb73f6f28f8e97bfb1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::set_difference_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>values_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_difference_by_key</code> performs a key-value difference operation from set theory. <code>set_difference_by_key</code> constructs a sorted range that is the difference of the sorted ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.</p>
<p>In the simplest case, <code>set_difference_by_key</code> performs the "difference" operation from set theory: the keys output range contains a copy of every element that is contained in <code>[keys_first1, keys_last1)</code> and not contained in <code>[keys_first2, keys_last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys_first1, keys_last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[keys_first2, keys_last2)</code> contains <code>n</code> elements that are equivalent to them, the last <code>max(m-n,0)</code> elements from <code>[keys_first1, keys_last1)</code> range shall be copied to the output range.</p>
<p>Each time a key element is copied from <code>[keys_first1, keys_last1)</code> or <code>[keys_first2, keys_last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values_first1</code> or <code>values_first2</code>) to the values output range.</p>
<p>This version of <code>set_difference_by_key</code> compares key elements using <code>operator&lt;</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">values_first2</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the output range of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator4</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator4's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_difference_by_key</code> to compute the set difference of two sets of integers sorted in ascending order with their values.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {0, 1, 3, 4, 5, 6, 9};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = {0, 0, 0, 0, 0, 0, 0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[5] = {1, 3, 5, 7, 9};</div>
<div class="line"><span class="keywordtype">int</span> B_vals[5] = {1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[3];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[3];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end = <a class="code" href="group__set__operations.html#ga062e76cd283cffd5391ef8254b45910a">thrust::set_difference_by_key</a>(A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);</div>
<div class="line"><span class="comment">// keys_result is now {0, 4, 6}</span></div>
<div class="line"><span class="comment">// vals_result is now {0, 0, 0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__set__operations.html#ga1b19cdab25f1dd1bafbe356296e7c0b8">set_union_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#gac9db7cdc6dc16466f46f8cdd29a4310e">set_intersection_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">set_symmetric_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3034549f40783b52e32a6d7f3d580c8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::set_difference_by_key </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>values_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_difference_by_key</code> performs a key-value difference operation from set theory. <code>set_difference_by_key</code> constructs a sorted range that is the difference of the sorted ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.</p>
<p>In the simplest case, <code>set_difference_by_key</code> performs the "difference" operation from set theory: the keys output range contains a copy of every element that is contained in <code>[keys_first1, keys_last1)</code> and not contained in <code>[keys_first2, keys_last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys_first1, keys_last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[keys_first2, keys_last2)</code> contains <code>n</code> elements that are equivalent to them, the last <code>max(m-n,0)</code> elements from <code>[keys_first1, keys_last1)</code> range shall be copied to the output range.</p>
<p>Each time a key element is copied from <code>[keys_first1, keys_last1)</code> or <code>[keys_first2, keys_last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values_first1</code> or <code>values_first2</code>) to the values output range.</p>
<p>This version of <code>set_difference_by_key</code> compares key elements using a function object <code>comp</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">values_first2</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the output range of values. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator4</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator4's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">StrictWeakCompare</td><td>is a model of <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict Weak Ordering</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_difference_by_key</code> to compute the set difference of two sets of integers sorted in descending order with their values using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {9, 6, 5, 4, 3, 1, 0};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = {0, 0, 0, 0, 0, 0, 0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[5] = {9, 7, 5, 3, 1};</div>
<div class="line"><span class="keywordtype">int</span> B_vals[5] = {1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[3];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[3];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end = <a class="code" href="group__set__operations.html#ga062e76cd283cffd5391ef8254b45910a">thrust::set_difference_by_key</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result, <a class="code" href="structthrust_1_1greater.html">thrust::greater&lt;int&gt;</a>());</div>
<div class="line"><span class="comment">// keys_result is now {0, 4, 6}</span></div>
<div class="line"><span class="comment">// vals_result is now {0, 0, 0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__set__operations.html#ga1b19cdab25f1dd1bafbe356296e7c0b8">set_union_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#gac9db7cdc6dc16466f46f8cdd29a4310e">set_intersection_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">set_symmetric_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga15aeb0c36bfdfca1e1d3f87b61d6add2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::set_difference_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>values_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_difference_by_key</code> performs a key-value difference operation from set theory. <code>set_difference_by_key</code> constructs a sorted range that is the difference of the sorted ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.</p>
<p>In the simplest case, <code>set_difference_by_key</code> performs the "difference" operation from set theory: the keys output range contains a copy of every element that is contained in <code>[keys_first1, keys_last1)</code> and not contained in <code>[keys_first2, keys_last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys_first1, keys_last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[keys_first2, keys_last2)</code> contains <code>n</code> elements that are equivalent to them, the last <code>max(m-n,0)</code> elements from <code>[keys_first1, keys_last1)</code> range shall be copied to the output range.</p>
<p>Each time a key element is copied from <code>[keys_first1, keys_last1)</code> or <code>[keys_first2, keys_last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values_first1</code> or <code>values_first2</code>) to the values output range.</p>
<p>This version of <code>set_difference_by_key</code> compares key elements using a function object <code>comp</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">values_first2</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the output range of values. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator4</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator4's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">StrictWeakCompare</td><td>is a model of <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict Weak Ordering</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_difference_by_key</code> to compute the set difference of two sets of integers sorted in descending order with their values.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {9, 6, 5, 4, 3, 1, 0};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = {0, 0, 0, 0, 0, 0, 0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[5] = {9, 7, 5, 3, 1};</div>
<div class="line"><span class="keywordtype">int</span> B_vals[5] = {1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[3];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[3];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end = <a class="code" href="group__set__operations.html#ga062e76cd283cffd5391ef8254b45910a">thrust::set_difference_by_key</a>(A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result, <a class="code" href="structthrust_1_1greater.html">thrust::greater&lt;int&gt;</a>());</div>
<div class="line"><span class="comment">// keys_result is now {0, 4, 6}</span></div>
<div class="line"><span class="comment">// vals_result is now {0, 0, 0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__set__operations.html#ga1b19cdab25f1dd1bafbe356296e7c0b8">set_union_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#gac9db7cdc6dc16466f46f8cdd29a4310e">set_intersection_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">set_symmetric_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e9671d6d44c7c384fa84bd4170eb431"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ OutputIterator thrust::set_intersection </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_intersection</code> constructs a sorted range that is the intersection of sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_intersection</code> performs the "intersection" operation from set theory: the output range contains a copy of every element that is contained in both <code>[first1, last1)</code> and <code>[first2, last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if a value appears <code>m</code> times in <code>[first1, last1)</code> and <code>n</code> times in <code>[first2, last2)</code> (where <code>m</code> may be zero), then it appears <code>min(m,n)</code> times in the output range. <code>set_intersection</code> is stable, meaning that both elements are copied from the first range rather than the second, and that the relative order of elements in the output range is the same as in the first input range.</p>
<p>This version of <code>set_intersection</code> compares objects using <code>operator&lt;</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_intersection</code> to compute the set intersection of two sets of integers sorted in ascending order using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[6] = {1, 3, 5, 7, 9, 11};</div>
<div class="line"><span class="keywordtype">int</span> A2[7] = {1, 1, 2, 3, 5,  8, 13};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[7];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">thrust::set_intersection</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, A1, A1 + 6, A2, A2 + 7, result);</div>
<div class="line"><span class="comment">// result is now {1, 3, 5}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/set_intersection.html">http://www.sgi.com/tech/stl/set_intersection.html</a> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga6fa1ae8ee04cadd3279288d96045b0c4">set_symmetric_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga939f2c87cff784afc63e39c5e5119784"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::set_intersection </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_intersection</code> constructs a sorted range that is the intersection of sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_intersection</code> performs the "intersection" operation from set theory: the output range contains a copy of every element that is contained in both <code>[first1, last1)</code> and <code>[first2, last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if a value appears <code>m</code> times in <code>[first1, last1)</code> and <code>n</code> times in <code>[first2, last2)</code> (where <code>m</code> may be zero), then it appears <code>min(m,n)</code> times in the output range. <code>set_intersection</code> is stable, meaning that both elements are copied from the first range rather than the second, and that the relative order of elements in the output range is the same as in the first input range.</p>
<p>This version of <code>set_intersection</code> compares objects using <code>operator&lt;</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_intersection</code> to compute the set intersection of two sets of integers sorted in ascending order.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[6] = {1, 3, 5, 7, 9, 11};</div>
<div class="line"><span class="keywordtype">int</span> A2[7] = {1, 1, 2, 3, 5,  8, 13};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[7];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">thrust::set_intersection</a>(A1, A1 + 6, A2, A2 + 7, result);</div>
<div class="line"><span class="comment">// result is now {1, 3, 5}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/set_intersection.html">http://www.sgi.com/tech/stl/set_intersection.html</a> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga6fa1ae8ee04cadd3279288d96045b0c4">set_symmetric_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga95576446f3a8f0302317d9ea2c9e8a74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ OutputIterator thrust::set_intersection </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_intersection</code> constructs a sorted range that is the intersection of sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_intersection</code> performs the "intersection" operation from set theory: the output range contains a copy of every element that is contained in both <code>[first1, last1)</code> and <code>[first2, last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if a value appears <code>m</code> times in <code>[first1, last1)</code> and <code>n</code> times in <code>[first2, last2)</code> (where <code>m</code> may be zero), then it appears <code>min(m,n)</code> times in the output range. <code>set_intersection</code> is stable, meaning that both elements are copied from the first range rather than the second, and that the relative order of elements in the output range is the same as in the first input range.</p>
<p>This version of <code>set_intersection</code> compares elements using a function object <code>comp</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>set_intersection</code> to compute the set intersection of sets of integers sorted in descending order using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[6] = {11, 9, 7, 5, 3, 1};</div>
<div class="line"><span class="keywordtype">int</span> A2[7] = {13, 8, 5, 3, 2,  1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[3];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">thrust::set_intersection</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, A1, A1 + 6, A2, A2 + 7, result, <a class="code" href="structthrust_1_1greater.html">thrust::greater&lt;int&gt;</a>());</div>
<div class="line"><span class="comment">// result is now {5, 3, 1}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/set_intersection.html">http://www.sgi.com/tech/stl/set_intersection.html</a> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga6fa1ae8ee04cadd3279288d96045b0c4">set_symmetric_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga63a7ebdaf5797f78be04febd436cd284"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::set_intersection </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_intersection</code> constructs a sorted range that is the intersection of sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_intersection</code> performs the "intersection" operation from set theory: the output range contains a copy of every element that is contained in both <code>[first1, last1)</code> and <code>[first2, last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if a value appears <code>m</code> times in <code>[first1, last1)</code> and <code>n</code> times in <code>[first2, last2)</code> (where <code>m</code> may be zero), then it appears <code>min(m,n)</code> times in the output range. <code>set_intersection</code> is stable, meaning that both elements are copied from the first range rather than the second, and that the relative order of elements in the output range is the same as in the first input range.</p>
<p>This version of <code>set_intersection</code> compares elements using a function object <code>comp</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>set_intersection</code> to compute the set intersection of sets of integers sorted in descending order.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[6] = {11, 9, 7, 5, 3, 1};</div>
<div class="line"><span class="keywordtype">int</span> A2[7] = {13, 8, 5, 3, 2,  1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[3];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">thrust::set_intersection</a>(A1, A1 + 6, A2, A2 + 7, result, <a class="code" href="structthrust_1_1greater.html">thrust::greater&lt;int&gt;</a>());</div>
<div class="line"><span class="comment">// result is now {5, 3, 1}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/set_intersection.html">http://www.sgi.com/tech/stl/set_intersection.html</a> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga6fa1ae8ee04cadd3279288d96045b0c4">set_symmetric_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="gac9db7cdc6dc16466f46f8cdd29a4310e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename OutputIterator1 , typename OutputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::set_intersection_by_key </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_intersection_by_key</code> performs a key-value intersection operation from set theory. <code>set_intersection_by_key</code> constructs a sorted range that is the intersection of the sorted ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.</p>
<p>In the simplest case, <code>set_intersection_by_key</code> performs the "intersection" operation from set theory: the keys output range contains a copy of every element that is contained in both <code>[keys_first1, keys_last1)</code> <code>[keys_first2, keys_last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if an element appears <code>m</code> times in <code>[keys_first1, keys_last1)</code> and <code>n</code> times in <code>[keys_first2, keys_last2)</code> (where <code>m</code> may be zero), then it appears <code>min(m,n)</code> times in the keys output range. <code>set_intersection_by_key</code> is stable, meaning both that elements are copied from the first input range rather than the second, and that the relative order of elements in the output range is the same as the first input range.</p>
<p>Each time a key element is copied from <code>[keys_first1, keys_last1)</code> to the keys output range, the corresponding value element is copied from <code>[values_first1, values_last1)</code> to the values output range.</p>
<p>This version of <code>set_intersection_by_key</code> compares objects using <code>operator&lt;</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the output range of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unlike the other key-value set operations, <code>set_intersection_by_key</code> is unique in that it has no <code>values_first2</code> parameter because elements from the second input range are never copied to the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_intersection_by_key</code> to compute the set intersection of two sets of integers sorted in ascending order with their values using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {1, 3, 5, 7, 9, 11};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = {0, 0, 0, 0, 0,  0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[7] = {1, 1, 2, 3, 5,  8, 13};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[7];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[7];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end = <a class="code" href="group__set__operations.html#gac9db7cdc6dc16466f46f8cdd29a4310e">thrust::set_intersection_by_key</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, A_keys, A_keys + 6, B_keys, B_keys + 7, A_vals, keys_result, vals_result);</div>
<div class="line"></div>
<div class="line"><span class="comment">// keys_result is now {1, 3, 5}</span></div>
<div class="line"><span class="comment">// vals_result is now {0, 0, 0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__set__operations.html#ga1b19cdab25f1dd1bafbe356296e7c0b8">set_union_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga062e76cd283cffd5391ef8254b45910a">set_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">set_symmetric_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga77564b343a17454dfb672a2acad7f80f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename OutputIterator1 , typename OutputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::set_intersection_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_intersection_by_key</code> performs a key-value intersection operation from set theory. <code>set_intersection_by_key</code> constructs a sorted range that is the intersection of the sorted ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.</p>
<p>In the simplest case, <code>set_intersection_by_key</code> performs the "intersection" operation from set theory: the keys output range contains a copy of every element that is contained in both <code>[keys_first1, keys_last1)</code> <code>[keys_first2, keys_last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if an element appears <code>m</code> times in <code>[keys_first1, keys_last1)</code> and <code>n</code> times in <code>[keys_first2, keys_last2)</code> (where <code>m</code> may be zero), then it appears <code>min(m,n)</code> times in the keys output range. <code>set_intersection_by_key</code> is stable, meaning both that elements are copied from the first input range rather than the second, and that the relative order of elements in the output range is the same as the first input range.</p>
<p>Each time a key element is copied from <code>[keys_first1, keys_last1)</code> to the keys output range, the corresponding value element is copied from <code>[values_first1, values_last1)</code> to the values output range.</p>
<p>This version of <code>set_intersection_by_key</code> compares objects using <code>operator&lt;</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the output range of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unlike the other key-value set operations, <code>set_intersection_by_key</code> is unique in that it has no <code>values_first2</code> parameter because elements from the second input range are never copied to the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_intersection_by_key</code> to compute the set intersection of two sets of integers sorted in ascending order with their values.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {1, 3, 5, 7, 9, 11};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = {0, 0, 0, 0, 0,  0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[7] = {1, 1, 2, 3, 5,  8, 13};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[7];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[7];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end = <a class="code" href="group__set__operations.html#gac9db7cdc6dc16466f46f8cdd29a4310e">thrust::set_intersection_by_key</a>(A_keys, A_keys + 6, B_keys, B_keys + 7, A_vals, keys_result, vals_result);</div>
<div class="line"></div>
<div class="line"><span class="comment">// keys_result is now {1, 3, 5}</span></div>
<div class="line"><span class="comment">// vals_result is now {0, 0, 0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__set__operations.html#ga1b19cdab25f1dd1bafbe356296e7c0b8">set_union_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga062e76cd283cffd5391ef8254b45910a">set_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">set_symmetric_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d0335a158421c13dd386942af1546eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename OutputIterator1 , typename OutputIterator2 , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::set_intersection_by_key </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_intersection_by_key</code> performs a key-value intersection operation from set theory. <code>set_intersection_by_key</code> constructs a sorted range that is the intersection of the sorted ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.</p>
<p>In the simplest case, <code>set_intersection_by_key</code> performs the "intersection" operation from set theory: the keys output range contains a copy of every element that is contained in both <code>[keys_first1, keys_last1)</code> <code>[keys_first2, keys_last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if an element appears <code>m</code> times in <code>[keys_first1, keys_last1)</code> and <code>n</code> times in <code>[keys_first2, keys_last2)</code> (where <code>m</code> may be zero), then it appears <code>min(m,n)</code> times in the keys output range. <code>set_intersection_by_key</code> is stable, meaning both that elements are copied from the first input range rather than the second, and that the relative order of elements in the output range is the same as the first input range.</p>
<p>Each time a key element is copied from <code>[keys_first1, keys_last1)</code> to the keys output range, the corresponding value element is copied from <code>[values_first1, values_last1)</code> to the values output range.</p>
<p>This version of <code>set_intersection_by_key</code> compares objects using a function object <code>comp</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the output range of values. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unlike the other key-value set operations, <code>set_intersection_by_key</code> is unique in that it has no <code>values_first2</code> parameter because elements from the second input range are never copied to the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">StrictWeakCompare</td><td>is a model of <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict Weak Ordering</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_intersection_by_key</code> to compute the set intersection of two sets of integers sorted in descending order with their values using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {11, 9, 7, 5, 3, 1};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = { 0, 0, 0, 0, 0, 0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[7] = {13, 8, 5, 3, 2, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[7];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[7];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end = <a class="code" href="group__set__operations.html#gac9db7cdc6dc16466f46f8cdd29a4310e">thrust::set_intersection_by_key</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, A_keys, A_keys + 6, B_keys, B_keys + 7, A_vals, keys_result, vals_result, <a class="code" href="structthrust_1_1greater.html">thrust::greater&lt;int&gt;</a>());</div>
<div class="line"></div>
<div class="line"><span class="comment">// keys_result is now {5, 3, 1}</span></div>
<div class="line"><span class="comment">// vals_result is now {0, 0, 0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__set__operations.html#ga1b19cdab25f1dd1bafbe356296e7c0b8">set_union_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga062e76cd283cffd5391ef8254b45910a">set_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">set_symmetric_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3fe9305ddfc3920adfeca1edc48d84d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename OutputIterator1 , typename OutputIterator2 , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::set_intersection_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_intersection_by_key</code> performs a key-value intersection operation from set theory. <code>set_intersection_by_key</code> constructs a sorted range that is the intersection of the sorted ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.</p>
<p>In the simplest case, <code>set_intersection_by_key</code> performs the "intersection" operation from set theory: the keys output range contains a copy of every element that is contained in both <code>[keys_first1, keys_last1)</code> <code>[keys_first2, keys_last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if an element appears <code>m</code> times in <code>[keys_first1, keys_last1)</code> and <code>n</code> times in <code>[keys_first2, keys_last2)</code> (where <code>m</code> may be zero), then it appears <code>min(m,n)</code> times in the keys output range. <code>set_intersection_by_key</code> is stable, meaning both that elements are copied from the first input range rather than the second, and that the relative order of elements in the output range is the same as the first input range.</p>
<p>Each time a key element is copied from <code>[keys_first1, keys_last1)</code> to the keys output range, the corresponding value element is copied from <code>[values_first1, values_last1)</code> to the values output range.</p>
<p>This version of <code>set_intersection_by_key</code> compares objects using a function object <code>comp</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the output range of values. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unlike the other key-value set operations, <code>set_intersection_by_key</code> is unique in that it has no <code>values_first2</code> parameter because elements from the second input range are never copied to the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">StrictWeakCompare</td><td>is a model of <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict Weak Ordering</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_intersection_by_key</code> to compute the set intersection of two sets of integers sorted in descending order with their values.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {11, 9, 7, 5, 3, 1};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = { 0, 0, 0, 0, 0, 0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[7] = {13, 8, 5, 3, 2, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[7];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[7];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end = <a class="code" href="group__set__operations.html#gac9db7cdc6dc16466f46f8cdd29a4310e">thrust::set_intersection_by_key</a>(A_keys, A_keys + 6, B_keys, B_keys + 7, A_vals, keys_result, vals_result, <a class="code" href="structthrust_1_1greater.html">thrust::greater&lt;int&gt;</a>());</div>
<div class="line"></div>
<div class="line"><span class="comment">// keys_result is now {5, 3, 1}</span></div>
<div class="line"><span class="comment">// vals_result is now {0, 0, 0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__set__operations.html#ga1b19cdab25f1dd1bafbe356296e7c0b8">set_union_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga062e76cd283cffd5391ef8254b45910a">set_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">set_symmetric_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6fa1ae8ee04cadd3279288d96045b0c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ OutputIterator thrust::set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_symmetric_difference</code> constructs a sorted range that is the set symmetric difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_symmetric_difference</code> performs a set theoretic calculation: it constructs the union of the two sets A - B and B - A, where A and B are the two input ranges. That is, the output range contains a copy of every element that is contained in <code>[first1, last1)</code> but not <code>[first2, last1)</code>, and a copy of every element that is contained in <code>[first2, last2)</code> but not <code>[first1, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and <code>[first2, last1)</code> contains <code>n</code> elements that are equivalent to them, then <code>|m - n|</code> of those elements shall be copied to the output range: the last <code>m - n</code> elements from <code>[first1, last1)</code> if <code>m &gt; n</code>, and the last <code>n - m</code> of these elements from <code>[first2, last2)</code> if <code>m &lt; n</code>.</p>
<p>This version of <code>set_union</code> compares elements using <code>operator&lt;</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_symmetric_difference</code> to compute the symmetric difference of two sets of integers sorted in ascending order using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[6] = {0, 1, 2, 2, 4, 6, 7};</div>
<div class="line"><span class="keywordtype">int</span> A2[5] = {1, 1, 2, 5, 8};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[6];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga6fa1ae8ee04cadd3279288d96045b0c4">thrust::set_symmetric_difference</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, A1, A1 + 6, A2, A2 + 5, result);</div>
<div class="line"><span class="comment">// result = {0, 4, 5, 6, 7, 8}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/set_symmetric_difference.html">http://www.sgi.com/tech/stl/set_symmetric_difference.html</a> </dd>
<dd>
<code><a class="el" href="group__merging.html#gad0269cdfcd1048406ca429c06f42fef1">merge</a></code> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#gadbd3cc430040aef1ead1a8885bd2bdc6">set_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga16bc72ce5444f82fca22e178b8370a98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_symmetric_difference</code> constructs a sorted range that is the set symmetric difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_symmetric_difference</code> performs a set theoretic calculation: it constructs the union of the two sets A - B and B - A, where A and B are the two input ranges. That is, the output range contains a copy of every element that is contained in <code>[first1, last1)</code> but not <code>[first2, last1)</code>, and a copy of every element that is contained in <code>[first2, last2)</code> but not <code>[first1, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and <code>[first2, last1)</code> contains <code>n</code> elements that are equivalent to them, then <code>|m - n|</code> of those elements shall be copied to the output range: the last <code>m - n</code> elements from <code>[first1, last1)</code> if <code>m &gt; n</code>, and the last <code>n - m</code> of these elements from <code>[first2, last2)</code> if <code>m &lt; n</code>.</p>
<p>This version of <code>set_union</code> compares elements using <code>operator&lt;</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_symmetric_difference</code> to compute the symmetric difference of two sets of integers sorted in ascending order.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[6] = {0, 1, 2, 2, 4, 6, 7};</div>
<div class="line"><span class="keywordtype">int</span> A2[5] = {1, 1, 2, 5, 8};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[6];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga6fa1ae8ee04cadd3279288d96045b0c4">thrust::set_symmetric_difference</a>(A1, A1 + 6, A2, A2 + 5, result);</div>
<div class="line"><span class="comment">// result = {0, 4, 5, 6, 7, 8}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/set_symmetric_difference.html">http://www.sgi.com/tech/stl/set_symmetric_difference.html</a> </dd>
<dd>
<code><a class="el" href="group__merging.html#gad0269cdfcd1048406ca429c06f42fef1">merge</a></code> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#gadbd3cc430040aef1ead1a8885bd2bdc6">set_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3999b76f6fa90b57f9b50bd69bcab8eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ OutputIterator thrust::set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_symmetric_difference</code> constructs a sorted range that is the set symmetric difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_symmetric_difference</code> performs a set theoretic calculation: it constructs the union of the two sets A - B and B - A, where A and B are the two input ranges. That is, the output range contains a copy of every element that is contained in <code>[first1, last1)</code> but not <code>[first2, last1)</code>, and a copy of every element that is contained in <code>[first2, last2)</code> but not <code>[first1, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and <code>[first2, last1)</code> contains <code>n</code> elements that are equivalent to them, then <code>|m - n|</code> of those elements shall be copied to the output range: the last <code>m - n</code> elements from <code>[first1, last1)</code> if <code>m &gt; n</code>, and the last <code>n - m</code> of these elements from <code>[first2, last2)</code> if <code>m &lt; n</code>.</p>
<p>This version of <code>set_union</code> compares elements using a function object <code>comp</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_symmetric_difference</code> to compute the symmetric difference of two sets of integers sorted in descending order using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[6] = {7, 6, 4, 2, 2, 1, 0};</div>
<div class="line"><span class="keywordtype">int</span> A2[5] = {8, 5, 2, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[6];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga6fa1ae8ee04cadd3279288d96045b0c4">thrust::set_symmetric_difference</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, A1, A1 + 6, A2, A2 + 5, result);</div>
<div class="line"><span class="comment">// result = {8, 7, 6, 5, 4, 0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/set_symmetric_difference.html">http://www.sgi.com/tech/stl/set_symmetric_difference.html</a> </dd>
<dd>
<code><a class="el" href="group__merging.html#gad0269cdfcd1048406ca429c06f42fef1">merge</a></code> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#gadbd3cc430040aef1ead1a8885bd2bdc6">set_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2194c9c4fe22397aff13e1c163c86446"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_symmetric_difference</code> constructs a sorted range that is the set symmetric difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_symmetric_difference</code> performs a set theoretic calculation: it constructs the union of the two sets A - B and B - A, where A and B are the two input ranges. That is, the output range contains a copy of every element that is contained in <code>[first1, last1)</code> but not <code>[first2, last1)</code>, and a copy of every element that is contained in <code>[first2, last2)</code> but not <code>[first1, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and <code>[first2, last1)</code> contains <code>n</code> elements that are equivalent to them, then <code>|m - n|</code> of those elements shall be copied to the output range: the last <code>m - n</code> elements from <code>[first1, last1)</code> if <code>m &gt; n</code>, and the last <code>n - m</code> of these elements from <code>[first2, last2)</code> if <code>m &lt; n</code>.</p>
<p>This version of <code>set_union</code> compares elements using a function object <code>comp</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_symmetric_difference</code> to compute the symmetric difference of two sets of integers sorted in descending order.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[6] = {7, 6, 4, 2, 2, 1, 0};</div>
<div class="line"><span class="keywordtype">int</span> A2[5] = {8, 5, 2, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[6];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga6fa1ae8ee04cadd3279288d96045b0c4">thrust::set_symmetric_difference</a>(A1, A1 + 6, A2, A2 + 5, result);</div>
<div class="line"><span class="comment">// result = {8, 7, 6, 5, 4, 0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/set_symmetric_difference.html">http://www.sgi.com/tech/stl/set_symmetric_difference.html</a> </dd>
<dd>
<code><a class="el" href="group__merging.html#gad0269cdfcd1048406ca429c06f42fef1">merge</a></code> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#gadbd3cc430040aef1ead1a8885bd2bdc6">set_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga00e191876364d0e340765fc8f90895cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::set_symmetric_difference_by_key </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>values_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_symmetric_difference_by_key</code> performs a key-value symmetric difference operation from set theory. <code>set_difference_by_key</code> constructs a sorted range that is the symmetric difference of the sorted ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.</p>
<p>In the simplest case, <code>set_symmetric_difference_by_key</code> performs a set theoretic calculation: it constructs the union of the two sets A - B and B - A, where A and B are the two input ranges. That is, the output range contains a copy of every element that is contained in <code>[keys_first1, keys_last1)</code> but not <code>[keys_first2, keys_last1)</code>, and a copy of every element that is contained in <code>[keys_first2, keys_last2)</code> but not <code>[keys_first1, keys_last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys_first1, keys_last1)</code> contains <code>m</code> elements that are equivalent to each other and <code>[keys_first2, keys_last1)</code> contains <code>n</code> elements that are equivalent to them, then <code>|m - n|</code> of those elements shall be copied to the output range: the last <code>m - n</code> elements from <code>[keys_first1, keys_last1)</code> if <code>m &gt; n</code>, and the last <code>n - m</code> of these elements from <code>[keys_first2, keys_last2)</code> if <code>m &lt; n</code>.</p>
<p>Each time a key element is copied from <code>[keys_first1, keys_last1)</code> or <code>[keys_first2, keys_last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values_first1</code> or <code>values_first2</code>) to the values output range.</p>
<p>This version of <code>set_symmetric_difference_by_key</code> compares key elements using <code>operator&lt;</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">values_first2</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the output range of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator4</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator4's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_symmetric_difference_by_key</code> to compute the symmetric difference of two sets of integers sorted in ascending order with their values using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {0, 1, 2, 2, 4, 6, 7};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = {0, 0, 0, 0, 0, 0, 0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[5] = {1, 1, 2, 5, 8};</div>
<div class="line"><span class="keywordtype">int</span> B_vals[5] = {1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[6];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[6];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end = <a class="code" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">thrust::set_symmetric_difference_by_key</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);</div>
<div class="line"><span class="comment">// keys_result is now {0, 4, 5, 6, 7, 8}</span></div>
<div class="line"><span class="comment">// vals_result is now {0, 0, 1, 0, 0, 1}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__set__operations.html#ga1b19cdab25f1dd1bafbe356296e7c0b8">set_union_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#gac9db7cdc6dc16466f46f8cdd29a4310e">set_intersection_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga062e76cd283cffd5391ef8254b45910a">set_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7bb0a94b88c9c7a5ce38ee3e3fe866d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::set_symmetric_difference_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>values_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_symmetric_difference_by_key</code> performs a key-value symmetric difference operation from set theory. <code>set_difference_by_key</code> constructs a sorted range that is the symmetric difference of the sorted ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.</p>
<p>In the simplest case, <code>set_symmetric_difference_by_key</code> performs a set theoretic calculation: it constructs the union of the two sets A - B and B - A, where A and B are the two input ranges. That is, the output range contains a copy of every element that is contained in <code>[keys_first1, keys_last1)</code> but not <code>[keys_first2, keys_last1)</code>, and a copy of every element that is contained in <code>[keys_first2, keys_last2)</code> but not <code>[keys_first1, keys_last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys_first1, keys_last1)</code> contains <code>m</code> elements that are equivalent to each other and <code>[keys_first2, keys_last1)</code> contains <code>n</code> elements that are equivalent to them, then <code>|m - n|</code> of those elements shall be copied to the output range: the last <code>m - n</code> elements from <code>[keys_first1, keys_last1)</code> if <code>m &gt; n</code>, and the last <code>n - m</code> of these elements from <code>[keys_first2, keys_last2)</code> if <code>m &lt; n</code>.</p>
<p>Each time a key element is copied from <code>[keys_first1, keys_last1)</code> or <code>[keys_first2, keys_last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values_first1</code> or <code>values_first2</code>) to the values output range.</p>
<p>This version of <code>set_symmetric_difference_by_key</code> compares key elements using <code>operator&lt;</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">values_first2</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the output range of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator4</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator4's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_symmetric_difference_by_key</code> to compute the symmetric difference of two sets of integers sorted in ascending order with their values.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {0, 1, 2, 2, 4, 6, 7};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = {0, 0, 0, 0, 0, 0, 0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[5] = {1, 1, 2, 5, 8};</div>
<div class="line"><span class="keywordtype">int</span> B_vals[5] = {1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[6];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[6];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end = <a class="code" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">thrust::set_symmetric_difference_by_key</a>(A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);</div>
<div class="line"><span class="comment">// keys_result is now {0, 4, 5, 6, 7, 8}</span></div>
<div class="line"><span class="comment">// vals_result is now {0, 0, 1, 0, 0, 1}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__set__operations.html#ga1b19cdab25f1dd1bafbe356296e7c0b8">set_union_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#gac9db7cdc6dc16466f46f8cdd29a4310e">set_intersection_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga062e76cd283cffd5391ef8254b45910a">set_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga01f25713cfd986ab8c03da1c259da11b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::set_symmetric_difference_by_key </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>values_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_symmetric_difference_by_key</code> performs a key-value symmetric difference operation from set theory. <code>set_difference_by_key</code> constructs a sorted range that is the symmetric difference of the sorted ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.</p>
<p>In the simplest case, <code>set_symmetric_difference_by_key</code> performs a set theoretic calculation: it constructs the union of the two sets A - B and B - A, where A and B are the two input ranges. That is, the output range contains a copy of every element that is contained in <code>[keys_first1, keys_last1)</code> but not <code>[keys_first2, keys_last1)</code>, and a copy of every element that is contained in <code>[keys_first2, keys_last2)</code> but not <code>[keys_first1, keys_last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys_first1, keys_last1)</code> contains <code>m</code> elements that are equivalent to each other and <code>[keys_first2, keys_last1)</code> contains <code>n</code> elements that are equivalent to them, then <code>|m - n|</code> of those elements shall be copied to the output range: the last <code>m - n</code> elements from <code>[keys_first1, keys_last1)</code> if <code>m &gt; n</code>, and the last <code>n - m</code> of these elements from <code>[keys_first2, keys_last2)</code> if <code>m &lt; n</code>.</p>
<p>Each time a key element is copied from <code>[keys_first1, keys_last1)</code> or <code>[keys_first2, keys_last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values_first1</code> or <code>values_first2</code>) to the values output range.</p>
<p>This version of <code>set_symmetric_difference_by_key</code> compares key elements using a function object <code>comp</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">values_first2</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the output range of values. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator4</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator4's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">StrictWeakCompare</td><td>is a model of <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict Weak Ordering</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_symmetric_difference_by_key</code> to compute the symmetric difference of two sets of integers sorted in descending order with their values using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {7, 6, 4, 2, 2, 1, 0};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = {0, 0, 0, 0, 0, 0, 0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[5] = {8, 5, 2, 1, 1};</div>
<div class="line"><span class="keywordtype">int</span> B_vals[5] = {1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[6];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[6];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end = <a class="code" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">thrust::set_symmetric_difference_by_key</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);</div>
<div class="line"><span class="comment">// keys_result is now {8, 7, 6, 5, 4, 0}</span></div>
<div class="line"><span class="comment">// vals_result is now {1, 0, 0, 1, 0, 0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__set__operations.html#ga1b19cdab25f1dd1bafbe356296e7c0b8">set_union_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#gac9db7cdc6dc16466f46f8cdd29a4310e">set_intersection_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga062e76cd283cffd5391ef8254b45910a">set_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb0747256e755a4f535e598fe245acec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::set_symmetric_difference_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>values_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_symmetric_difference_by_key</code> performs a key-value symmetric difference operation from set theory. <code>set_difference_by_key</code> constructs a sorted range that is the symmetric difference of the sorted ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.</p>
<p>In the simplest case, <code>set_symmetric_difference_by_key</code> performs a set theoretic calculation: it constructs the union of the two sets A - B and B - A, where A and B are the two input ranges. That is, the output range contains a copy of every element that is contained in <code>[keys_first1, keys_last1)</code> but not <code>[keys_first2, keys_last1)</code>, and a copy of every element that is contained in <code>[keys_first2, keys_last2)</code> but not <code>[keys_first1, keys_last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys_first1, keys_last1)</code> contains <code>m</code> elements that are equivalent to each other and <code>[keys_first2, keys_last1)</code> contains <code>n</code> elements that are equivalent to them, then <code>|m - n|</code> of those elements shall be copied to the output range: the last <code>m - n</code> elements from <code>[keys_first1, keys_last1)</code> if <code>m &gt; n</code>, and the last <code>n - m</code> of these elements from <code>[keys_first2, keys_last2)</code> if <code>m &lt; n</code>.</p>
<p>Each time a key element is copied from <code>[keys_first1, keys_last1)</code> or <code>[keys_first2, keys_last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values_first1</code> or <code>values_first2</code>) to the values output range.</p>
<p>This version of <code>set_symmetric_difference_by_key</code> compares key elements using a function object <code>comp</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">values_first2</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the output range of values. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator4</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator4's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">StrictWeakCompare</td><td>is a model of <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict Weak Ordering</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_symmetric_difference_by_key</code> to compute the symmetric difference of two sets of integers sorted in descending order with their values.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {7, 6, 4, 2, 2, 1, 0};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = {0, 0, 0, 0, 0, 0, 0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[5] = {8, 5, 2, 1, 1};</div>
<div class="line"><span class="keywordtype">int</span> B_vals[5] = {1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[6];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[6];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end = <a class="code" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">thrust::set_symmetric_difference_by_key</a>(A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);</div>
<div class="line"><span class="comment">// keys_result is now {8, 7, 6, 5, 4, 0}</span></div>
<div class="line"><span class="comment">// vals_result is now {1, 0, 0, 1, 0, 0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__set__operations.html#ga1b19cdab25f1dd1bafbe356296e7c0b8">set_union_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#gac9db7cdc6dc16466f46f8cdd29a4310e">set_intersection_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga062e76cd283cffd5391ef8254b45910a">set_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga974aed5fabc60590b7efa20464021caf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ OutputIterator thrust::set_union </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_union</code> constructs a sorted range that is the union of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_union</code> performs the "union" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code>, <code>[first2, last1)</code>, or both. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, then all <code>m</code> elements from the first range shall be copied to the output range, in order, and then <code>max(n - m, 0)</code> elements from the second range shall be copied to the output, in order.</p>
<p>This version of <code>set_union</code> compares elements using <code>operator&lt;</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_union</code> to compute the union of two sets of integers sorted in ascending order using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[7] = {0, 2, 4, 6, 8, 10, 12};</div>
<div class="line"><span class="keywordtype">int</span> A2[5] = {1, 3, 5, 7, 9};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[11];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">thrust::set_union</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, A1, A1 + 7, A2, A2 + 5, result);</div>
<div class="line"><span class="comment">// result = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/set_union.html">http://www.sgi.com/tech/stl/set_union.html</a> </dd>
<dd>
<code><a class="el" href="group__merging.html#gad0269cdfcd1048406ca429c06f42fef1">merge</a></code> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga6fa1ae8ee04cadd3279288d96045b0c4">set_symmetric_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="gaae9a47e263655f0e56b1a4860182d4a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::set_union </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_union</code> constructs a sorted range that is the union of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_union</code> performs the "union" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code>, <code>[first2, last1)</code>, or both. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, then all <code>m</code> elements from the first range shall be copied to the output range, in order, and then <code>max(n - m, 0)</code> elements from the second range shall be copied to the output, in order.</p>
<p>This version of <code>set_union</code> compares elements using <code>operator&lt;</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_union</code> to compute the union of two sets of integers sorted in ascending order.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[7] = {0, 2, 4, 6, 8, 10, 12};</div>
<div class="line"><span class="keywordtype">int</span> A2[5] = {1, 3, 5, 7, 9};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[11];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">thrust::set_union</a>(A1, A1 + 7, A2, A2 + 5, result);</div>
<div class="line"><span class="comment">// result = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/set_union.html">http://www.sgi.com/tech/stl/set_union.html</a> </dd>
<dd>
<code><a class="el" href="group__merging.html#gad0269cdfcd1048406ca429c06f42fef1">merge</a></code> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga6fa1ae8ee04cadd3279288d96045b0c4">set_symmetric_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga61a7f2ee79a8a7a2c61e22cb24f369f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ OutputIterator thrust::set_union </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_union</code> constructs a sorted range that is the union of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_union</code> performs the "union" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code>, <code>[first2, last1)</code>, or both. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, then all <code>m</code> elements from the first range shall be copied to the output range, in order, and then <code>max(n - m, 0)</code> elements from the second range shall be copied to the output, in order.</p>
<p>This version of <code>set_union</code> compares elements using a function object <code>comp</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>first_argument_type</code>. and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>second_argument_type</code>. and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">StrictWeakCompare</td><td>is a model of <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict Weak Ordering</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_union</code> to compute the union of two sets of integers sorted in ascending order using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[7] = {12, 10, 8, 6, 4, 2, 0};</div>
<div class="line"><span class="keywordtype">int</span> A2[5] = {9, 7, 5, 3, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[11];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">thrust::set_union</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, A1, A1 + 7, A2, A2 + 5, result, <a class="code" href="structthrust_1_1greater.html">thrust::greater&lt;int&gt;</a>());</div>
<div class="line"><span class="comment">// result = {12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/set_union.html">http://www.sgi.com/tech/stl/set_union.html</a> </dd>
<dd>
<code><a class="el" href="group__merging.html#gad0269cdfcd1048406ca429c06f42fef1">merge</a></code> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga6fa1ae8ee04cadd3279288d96045b0c4">set_symmetric_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5d768feeec14f067304bf66bf59aaecf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::set_union </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_union</code> constructs a sorted range that is the union of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_union</code> performs the "union" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code>, <code>[first2, last1)</code>, or both. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, then all <code>m</code> elements from the first range shall be copied to the output range, in order, and then <code>max(n - m, 0)</code> elements from the second range shall be copied to the output, in order.</p>
<p>This version of <code>set_union</code> compares elements using a function object <code>comp</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>first_argument_type</code>. and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>second_argument_type</code>. and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">StrictWeakCompare</td><td>is a model of <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict Weak Ordering</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_union</code> to compute the union of two sets of integers sorted in ascending order.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[7] = {12, 10, 8, 6, 4, 2, 0};</div>
<div class="line"><span class="keywordtype">int</span> A2[5] = {9, 7, 5, 3, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[11];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">thrust::set_union</a>(A1, A1 + 7, A2, A2 + 5, result, <a class="code" href="structthrust_1_1greater.html">thrust::greater&lt;int&gt;</a>());</div>
<div class="line"><span class="comment">// result = {12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/set_union.html">http://www.sgi.com/tech/stl/set_union.html</a> </dd>
<dd>
<code><a class="el" href="group__merging.html#gad0269cdfcd1048406ca429c06f42fef1">merge</a></code> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7e9671d6d44c7c384fa84bd4170eb431">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga6fa1ae8ee04cadd3279288d96045b0c4">set_symmetric_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b19cdab25f1dd1bafbe356296e7c0b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::set_union_by_key </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>values_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_union_by_key</code> performs a key-value union operation from set theory. <code>set_union_by_key</code> constructs a sorted range that is the union of the sorted ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.</p>
<p>In the simplest case, <code>set_union_by_key</code> performs the "union" operation from set theory: the output range contains a copy of every element that is contained in <code>[keys_first1, keys_last1)</code>, <code>[keys_first2, keys_last1)</code>, or both. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys_first1, keys_last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[keys_first2, keys_last2)</code> contains <code>n</code> elements that are equivalent to them, then all <code>m</code> elements from the first range shall be copied to the output range, in order, and then <code>max(n - m, 0)</code> elements from the second range shall be copied to the output, in order.</p>
<p>Each time a key element is copied from <code>[keys_first1, keys_last1)</code> or <code>[keys_first2, keys_last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values_first1</code> or <code>values_first2</code>) to the values output range.</p>
<p>This version of <code>set_union_by_key</code> compares key elements using <code>operator&lt;</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">values_first2</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the output range of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator4</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator4's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_symmetric_difference_by_key</code> to compute the symmetric difference of two sets of integers sorted in ascending order with their values using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {0, 2, 4, 6, 8, 10, 12};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = {0, 0, 0, 0, 0,  0,  0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[5] = {1, 3, 5, 7, 9};</div>
<div class="line"><span class="keywordtype">int</span> B_vals[5] = {1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[11];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[11];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end = <a class="code" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">thrust::set_symmetric_difference_by_key</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);</div>
<div class="line"><span class="comment">// keys_result is now {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12}</span></div>
<div class="line"><span class="comment">// vals_result is now {0, 1, 0, 1, 0, 1, 0, 1, 0, 1,  0,  0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">set_symmetric_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#gac9db7cdc6dc16466f46f8cdd29a4310e">set_intersection_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga062e76cd283cffd5391ef8254b45910a">set_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b78f1cfc290b9bf0579a074729c8149"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::set_union_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>values_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_union_by_key</code> performs a key-value union operation from set theory. <code>set_union_by_key</code> constructs a sorted range that is the union of the sorted ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.</p>
<p>In the simplest case, <code>set_union_by_key</code> performs the "union" operation from set theory: the output range contains a copy of every element that is contained in <code>[keys_first1, keys_last1)</code>, <code>[keys_first2, keys_last1)</code>, or both. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys_first1, keys_last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[keys_first2, keys_last2)</code> contains <code>n</code> elements that are equivalent to them, then all <code>m</code> elements from the first range shall be copied to the output range, in order, and then <code>max(n - m, 0)</code> elements from the second range shall be copied to the output, in order.</p>
<p>Each time a key element is copied from <code>[keys_first1, keys_last1)</code> or <code>[keys_first2, keys_last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values_first1</code> or <code>values_first2</code>) to the values output range.</p>
<p>This version of <code>set_union_by_key</code> compares key elements using <code>operator&lt;</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">values_first2</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the output range of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator4</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator4's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_symmetric_difference_by_key</code> to compute the symmetric difference of two sets of integers sorted in ascending order with their values.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {0, 2, 4, 6, 8, 10, 12};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = {0, 0, 0, 0, 0,  0,  0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[5] = {1, 3, 5, 7, 9};</div>
<div class="line"><span class="keywordtype">int</span> B_vals[5] = {1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[11];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[11];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end = <a class="code" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">thrust::set_symmetric_difference_by_key</a>(A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);</div>
<div class="line"><span class="comment">// keys_result is now {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12}</span></div>
<div class="line"><span class="comment">// vals_result is now {0, 1, 0, 1, 0, 1, 0, 1, 0, 1,  0,  0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">set_symmetric_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#gac9db7cdc6dc16466f46f8cdd29a4310e">set_intersection_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga062e76cd283cffd5391ef8254b45910a">set_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="gaabefb2fcb73e2d1ea5efab778e174240"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::set_union_by_key </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>values_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_union_by_key</code> performs a key-value union operation from set theory. <code>set_union_by_key</code> constructs a sorted range that is the union of the sorted ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.</p>
<p>In the simplest case, <code>set_union_by_key</code> performs the "union" operation from set theory: the output range contains a copy of every element that is contained in <code>[keys_first1, keys_last1)</code>, <code>[keys_first2, keys_last1)</code>, or both. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys_first1, keys_last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[keys_first2, keys_last2)</code> contains <code>n</code> elements that are equivalent to them, then all <code>m</code> elements from the first range shall be copied to the output range, in order, and then <code>max(n - m, 0)</code> elements from the second range shall be copied to the output, in order.</p>
<p>Each time a key element is copied from <code>[keys_first1, keys_last1)</code> or <code>[keys_first2, keys_last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values_first1</code> or <code>values_first2</code>) to the values output range.</p>
<p>This version of <code>set_union_by_key</code> compares key elements using a function object <code>comp</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">values_first2</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the output range of values. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator4</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator4's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">StrictWeakCompare</td><td>is a model of <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict Weak Ordering</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_symmetric_difference_by_key</code> to compute the symmetric difference of two sets of integers sorted in descending order with their values using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {12, 10, 8, 6, 4, 2, 0};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = { 0,  0, 0, 0, 0, 0, 0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[5] = {9, 7, 5, 3, 1};</div>
<div class="line"><span class="keywordtype">int</span> B_vals[5] = {1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[11];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[11];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end = <a class="code" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">thrust::set_symmetric_difference_by_key</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result, <a class="code" href="structthrust_1_1greater.html">thrust::greater&lt;int&gt;</a>());</div>
<div class="line"><span class="comment">// keys_result is now {12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}</span></div>
<div class="line"><span class="comment">// vals_result is now { 0,  1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">set_symmetric_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#gac9db7cdc6dc16466f46f8cdd29a4310e">set_intersection_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga062e76cd283cffd5391ef8254b45910a">set_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="gace7a92108ce79b7d43f060b46a0c776c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::set_union_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>values_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>set_union_by_key</code> performs a key-value union operation from set theory. <code>set_union_by_key</code> constructs a sorted range that is the union of the sorted ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.</p>
<p>In the simplest case, <code>set_union_by_key</code> performs the "union" operation from set theory: the output range contains a copy of every element that is contained in <code>[keys_first1, keys_last1)</code>, <code>[keys_first2, keys_last1)</code>, or both. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys_first1, keys_last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[keys_first2, keys_last2)</code> contains <code>n</code> elements that are equivalent to them, then all <code>m</code> elements from the first range shall be copied to the output range, in order, and then <code>max(n - m, 0)</code> elements from the second range shall be copied to the output, in order.</p>
<p>Each time a key element is copied from <code>[keys_first1, keys_last1)</code> or <code>[keys_first2, keys_last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values_first1</code> or <code>values_first2</code>) to the values output range.</p>
<p>This version of <code>set_union_by_key</code> compares key elements using a function object <code>comp</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">values_first2</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the output range of values. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator4</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator4's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">StrictWeakCompare</td><td>is a model of <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict Weak Ordering</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>set_symmetric_difference_by_key</code> to compute the symmetric difference of two sets of integers sorted in descending order with their values.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set__operations_8h.html">thrust/set_operations.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {12, 10, 8, 6, 4, 2, 0};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = { 0,  0, 0, 0, 0, 0, 0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[5] = {9, 7, 5, 3, 1};</div>
<div class="line"><span class="keywordtype">int</span> B_vals[5] = {1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[11];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[11];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end = <a class="code" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">thrust::set_symmetric_difference_by_key</a>(A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result, <a class="code" href="structthrust_1_1greater.html">thrust::greater&lt;int&gt;</a>());</div>
<div class="line"><span class="comment">// keys_result is now {12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}</span></div>
<div class="line"><span class="comment">// vals_result is now { 0,  1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__set__operations.html#ga00e191876364d0e340765fc8f90895cd">set_symmetric_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#gac9db7cdc6dc16466f46f8cdd29a4310e">set_intersection_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga062e76cd283cffd5391ef8254b45910a">set_difference_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 2 2015 13:21:30 for thrust by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
