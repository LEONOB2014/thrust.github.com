<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>thrust: Set Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">thrust</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Set Operations</div>  </div>
<div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga37985609f9f0671d45249d1d42c259ce">thrust::set_difference</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#gacebdd5b8f408e403613b242b86406b07">thrust::set_difference</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga17277fec1491c8a916c9908a5ae40807">thrust::set_intersection</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga235d1ad5eae1b81be5830322cd33ccbe">thrust::set_intersection</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga2a6e7275fd83a3079804d143542c7b17">thrust::set_symmetric_difference</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#gaba42e4ea1667cb817cffb2310073078b">thrust::set_symmetric_difference</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga7fb6690a07e030091851eeff23a2f93a">thrust::set_union</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#gadff01587848d3a8110bf71c59ed75635">thrust::set_union</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga37985609f9f0671d45249d1d42c259ce"></a><!-- doxytag: member="thrust::set_difference" ref="ga37985609f9f0671d45249d1d42c259ce" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::set_difference </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>set_difference</code> constructs a sorted range that is the set difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_difference</code> performs the "difference" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code> and not contained in <code>[first2, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, the last <code>max(m-n,0)</code> elements from <code>[first1, last1)</code> range shall be copied to the output range.</p>
<p>This version of <code>set_difference</code> compares elements using <code>operator&lt;</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the output range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>set_difference</code> to compute the set difference of two sets of integers sorted in ascending order.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="set__operations_8h.html" title="Set theoretic operations for sorted ranges.">thrust/set_operations.h</a>&gt;</span>
  ...
  <span class="keywordtype">int</span> A1[6] = {0, 1, 3, 4, 5, 6, 9};
  <span class="keywordtype">int</span> A2[5] = {1, 3, 5, 7, 9};

  <span class="keywordtype">int</span> result[3];

  <span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga37985609f9f0671d45249d1d42c259ce">thrust::set_difference</a>(A1, A1 + 6, A2, A2 + 5, result);
  <span class="comment">// result is now {0, 4, 6}</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/set_difference.html">http://www.sgi.com/tech/stl/set_difference.html</a> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7fb6690a07e030091851eeff23a2f93a">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga17277fec1491c8a916c9908a5ae40807">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga2a6e7275fd83a3079804d143542c7b17">set_symmetric_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga8fd4df95e8e16c89ff92737947daa1f9">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#gadb8e5879d64546addb3b252c214e3bea">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="gacebdd5b8f408e403613b242b86406b07"></a><!-- doxytag: member="thrust::set_difference" ref="gacebdd5b8f408e403613b242b86406b07" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::set_difference </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>set_difference</code> constructs a sorted range that is the set difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_difference</code> performs the "difference" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code> and not contained in <code>[first2, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, the last <code>max(m-n,0)</code> elements from <code>[first1, last1)</code> range shall be copied to the output range.</p>
<p>This version of <code>set_difference</code> compares elements using a function object <code>comp</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the output range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>first_argument_type</code>. and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>second_argument_type</code>. and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">StrictWeakCompare</td><td>is a model of <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict Weak Ordering</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>set_difference</code> to compute the set difference of two sets of integers sorted in descending order.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="set__operations_8h.html" title="Set theoretic operations for sorted ranges.">thrust/set_operations.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="functional_8h.html" title="Function objects and tools for manipulating them.">thrust/functional.h</a>&gt;</span>
  ...
  <span class="keywordtype">int</span> A1[6] = {9, 6, 5, 4, 3, 1, 0};
  <span class="keywordtype">int</span> A2[5] = {9, 7, 5, 3, 1};

  <span class="keywordtype">int</span> result[3];

  <span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga37985609f9f0671d45249d1d42c259ce">thrust::set_difference</a>(A1, A1 + 6, A2, A2 + 5, result, <a class="code" href="structthrust_1_1greater.html">thrust::greater&lt;int&gt;</a>());
  <span class="comment">// result is now {6, 4, 0}</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/set_difference.html">http://www.sgi.com/tech/stl/set_difference.html</a> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7fb6690a07e030091851eeff23a2f93a">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga17277fec1491c8a916c9908a5ae40807">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga2a6e7275fd83a3079804d143542c7b17">set_symmetric_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga8fd4df95e8e16c89ff92737947daa1f9">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#gadb8e5879d64546addb3b252c214e3bea">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga235d1ad5eae1b81be5830322cd33ccbe"></a><!-- doxytag: member="thrust::set_intersection" ref="ga235d1ad5eae1b81be5830322cd33ccbe" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::set_intersection </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>set_intersection</code> constructs a sorted range that is the intersection of sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_intersection</code> performs the "intersection" operation from set theory: the output range contains a copy of every element that is contained in both <code>[first1, last1)</code> and <code>[first2, last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if a value appears <code>m</code> times in <code>[first1, last1)</code> and <code>n</code> times in <code>[first2, last2)</code> (where <code>m</code> may be zero), then it appears <code>min(m,n)</code> times in the output range. <code>set_intersection</code> is stable, meaning that both elements are copied from the first range rather than the second, and that the relative order of elements in the output range is the same as in the first input range.</p>
<p>This version of <code>set_intersection</code> compares elements using a function object <code>comp</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the output range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>set_intersection</code> to compute the set intersection of sets of integers sorted in descending order.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="set__operations_8h.html" title="Set theoretic operations for sorted ranges.">thrust/set_operations.h</a>&gt;</span>
  ...
  <span class="keywordtype">int</span> A1[6] = {11, 9, 7, 5, 3, 1};
  <span class="keywordtype">int</span> A2[7] = {13, 8, 5, 3, 2,  1, 1};

  <span class="keywordtype">int</span> result[3];

  <span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga17277fec1491c8a916c9908a5ae40807">thrust::set_intersection</a>(A1, A1 + 6, A2, A2 + 7, result, <a class="code" href="structthrust_1_1greater.html">thrust::greater&lt;int&gt;</a>());
  <span class="comment">// result is now {5, 3, 1}</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/set_intersection.html">http://www.sgi.com/tech/stl/set_intersection.html</a> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7fb6690a07e030091851eeff23a2f93a">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga17277fec1491c8a916c9908a5ae40807">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga2a6e7275fd83a3079804d143542c7b17">set_symmetric_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga8fd4df95e8e16c89ff92737947daa1f9">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#gadb8e5879d64546addb3b252c214e3bea">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga17277fec1491c8a916c9908a5ae40807"></a><!-- doxytag: member="thrust::set_intersection" ref="ga17277fec1491c8a916c9908a5ae40807" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::set_intersection </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>set_intersection</code> constructs a sorted range that is the intersection of sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_intersection</code> performs the "intersection" operation from set theory: the output range contains a copy of every element that is contained in both <code>[first1, last1)</code> and <code>[first2, last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if a value appears <code>m</code> times in <code>[first1, last1)</code> and <code>n</code> times in <code>[first2, last2)</code> (where <code>m</code> may be zero), then it appears <code>min(m,n)</code> times in the output range. <code>set_intersection</code> is stable, meaning that both elements are copied from the first range rather than the second, and that the relative order of elements in the output range is the same as in the first input range.</p>
<p>This version of <code>set_intersection</code> compares objects using <code>operator&lt;</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the output range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>set_intersection</code> to compute the set intersection of two sets of integers sorted in ascending order.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="set__operations_8h.html" title="Set theoretic operations for sorted ranges.">thrust/set_operations.h</a>&gt;</span>
  ...
  <span class="keywordtype">int</span> A1[6] = {1, 3, 5, 7, 9, 11};
  <span class="keywordtype">int</span> A2[7] = {1, 1, 2, 3, 5,  8, 13};

  <span class="keywordtype">int</span> result[7];

  <span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga17277fec1491c8a916c9908a5ae40807">thrust::set_intersection</a>(A1, A1 + 6, A2, A2 + 7, result);
  <span class="comment">// result is now {1, 3, 5}</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/set_intersection.html">http://www.sgi.com/tech/stl/set_intersection.html</a> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7fb6690a07e030091851eeff23a2f93a">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga17277fec1491c8a916c9908a5ae40807">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga2a6e7275fd83a3079804d143542c7b17">set_symmetric_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga8fd4df95e8e16c89ff92737947daa1f9">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#gadb8e5879d64546addb3b252c214e3bea">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2a6e7275fd83a3079804d143542c7b17"></a><!-- doxytag: member="thrust::set_symmetric_difference" ref="ga2a6e7275fd83a3079804d143542c7b17" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>set_symmetric_difference</code> constructs a sorted range that is the set symmetric difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_symmetric_difference</code> performs a set theoretic calculation: it constructs the union of the two sets A - B and B - A, where A and B are the two input ranges. That is, the output range contains a copy of every element that is contained in <code>[first1, last1)</code> but not <code>[first2, last1)</code>, and a copy of every element that is contained in <code>[first2, last2)</code> but not <code>[first1, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and <code>[first2, last1)</code> contains <code>n</code> elements that are equivalent to them, then <code>|m - n|</code> of those elements shall be copied to the output range: the last <code>m - n</code> elements from <code>[first1, last1)</code> if <code>m &gt; n</code>, and the last <code>n - m</code> of these elements from <code>[first2, last2)</code> if <code>m &lt; n</code>.</p>
<p>This version of <code>set_union</code> compares elements using <code>operator&lt;</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the output range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>set_symmetric_difference</code> to compute the symmetric difference of two sets of integers sorted in ascending order.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="set__operations_8h.html" title="Set theoretic operations for sorted ranges.">thrust/set_operations.h</a>&gt;</span>
  ...
  <span class="keywordtype">int</span> A1[6] = {0, 1, 2, 2, 4, 6, 7};
  <span class="keywordtype">int</span> A2[5] = {1, 1, 2, 5, 8};

  <span class="keywordtype">int</span> result[6];

  <span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga2a6e7275fd83a3079804d143542c7b17">thrust::set_symmetric_difference</a>(A1, A1 + 6, A2, A2 + 5, result);
  <span class="comment">// result = {0, 4, 5, 6, 7, 8}</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/set_symmetric_difference.html">http://www.sgi.com/tech/stl/set_symmetric_difference.html</a> </dd>
<dd>
<code><a class="el" href="group__merging.html#ga91d42e699631de9f7647090c91eadf7a">merge</a></code> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga37985609f9f0671d45249d1d42c259ce">set_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7fb6690a07e030091851eeff23a2f93a">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga17277fec1491c8a916c9908a5ae40807">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga8fd4df95e8e16c89ff92737947daa1f9">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#gadb8e5879d64546addb3b252c214e3bea">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="gaba42e4ea1667cb817cffb2310073078b"></a><!-- doxytag: member="thrust::set_symmetric_difference" ref="gaba42e4ea1667cb817cffb2310073078b" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>set_symmetric_difference</code> constructs a sorted range that is the set symmetric difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_symmetric_difference</code> performs a set theoretic calculation: it constructs the union of the two sets A - B and B - A, where A and B are the two input ranges. That is, the output range contains a copy of every element that is contained in <code>[first1, last1)</code> but not <code>[first2, last1)</code>, and a copy of every element that is contained in <code>[first2, last2)</code> but not <code>[first1, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and <code>[first2, last1)</code> contains <code>n</code> elements that are equivalent to them, then <code>|m - n|</code> of those elements shall be copied to the output range: the last <code>m - n</code> elements from <code>[first1, last1)</code> if <code>m &gt; n</code>, and the last <code>n - m</code> of these elements from <code>[first2, last2)</code> if <code>m &lt; n</code>.</p>
<p>This version of <code>set_union</code> compares elements using a function object <code>comp</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the output range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>set_symmetric_difference</code> to compute the symmetric difference of two sets of integers sorted in descending order.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="set__operations_8h.html" title="Set theoretic operations for sorted ranges.">thrust/set_operations.h</a>&gt;</span>
  ...
  <span class="keywordtype">int</span> A1[6] = {7, 6, 4, 2, 2, 1, 0};
  <span class="keywordtype">int</span> A2[5] = {8, 5, 2, 1, 1};

  <span class="keywordtype">int</span> result[6];

  <span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga2a6e7275fd83a3079804d143542c7b17">thrust::set_symmetric_difference</a>(A1, A1 + 6, A2, A2 + 5, result);
  <span class="comment">// result = {8, 7, 6, 5, 4, 0}</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/set_symmetric_difference.html">http://www.sgi.com/tech/stl/set_symmetric_difference.html</a> </dd>
<dd>
<code><a class="el" href="group__merging.html#ga91d42e699631de9f7647090c91eadf7a">merge</a></code> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga37985609f9f0671d45249d1d42c259ce">set_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7fb6690a07e030091851eeff23a2f93a">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga17277fec1491c8a916c9908a5ae40807">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga8fd4df95e8e16c89ff92737947daa1f9">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#gadb8e5879d64546addb3b252c214e3bea">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="gadff01587848d3a8110bf71c59ed75635"></a><!-- doxytag: member="thrust::set_union" ref="gadff01587848d3a8110bf71c59ed75635" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::set_union </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>set_union</code> constructs a sorted range that is the union of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_union</code> performs the "union" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code>, <code>[first2, last1)</code>, or both. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, then all <code>m</code> elements from the first range shall be copied to the output range, in order, and then <code>max(n - m, 0)</code> elements from the second range shall be copied to the output, in order.</p>
<p>This version of <code>set_union</code> compares elements using a function object <code>comp</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the output range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>first_argument_type</code>. and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>second_argument_type</code>. and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">StrictWeakCompare</td><td>is a model of <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict Weak Ordering</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>set_union</code> to compute the union of two sets of integers sorted in ascending order.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="set__operations_8h.html" title="Set theoretic operations for sorted ranges.">thrust/set_operations.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="functional_8h.html" title="Function objects and tools for manipulating them.">thrust/functional.h</a>&gt;</span>
  ...
  <span class="keywordtype">int</span> A1[6] = {12, 10, 8, 6, 4, 2, 12};
  <span class="keywordtype">int</span> A2[5] = {9, 7, 5, 3, 1};

  <span class="keywordtype">int</span> result[11];

  <span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga7fb6690a07e030091851eeff23a2f93a">thrust::set_union</a>(A1, A1 + 6, A2, A2 + 5, result, <a class="code" href="structthrust_1_1greater.html">thrust::greater&lt;int&gt;</a>());
  <span class="comment">// result = {12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/set_union.html">http://www.sgi.com/tech/stl/set_union.html</a> </dd>
<dd>
<code><a class="el" href="group__merging.html#ga91d42e699631de9f7647090c91eadf7a">merge</a></code> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7fb6690a07e030091851eeff23a2f93a">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga17277fec1491c8a916c9908a5ae40807">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga2a6e7275fd83a3079804d143542c7b17">set_symmetric_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga8fd4df95e8e16c89ff92737947daa1f9">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#gadb8e5879d64546addb3b252c214e3bea">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7fb6690a07e030091851eeff23a2f93a"></a><!-- doxytag: member="thrust::set_union" ref="ga7fb6690a07e030091851eeff23a2f93a" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::set_union </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>set_union</code> constructs a sorted range that is the union of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.</p>
<p>In the simplest case, <code>set_union</code> performs the "union" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code>, <code>[first2, last1)</code>, or both. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, then all <code>m</code> elements from the first range shall be copied to the output range, in order, and then <code>max(n - m, 0)</code> elements from the second range shall be copied to the output, in order.</p>
<p>This version of <code>set_union</code> compares elements using <code>operator&lt;</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the output range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>set_union</code> to compute the union of two sets of integers sorted in ascending order.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="set__operations_8h.html" title="Set theoretic operations for sorted ranges.">thrust/set_operations.h</a>&gt;</span>
  ...
  <span class="keywordtype">int</span> A1[6] = {0, 2, 4, 6, 8, 10, 12};
  <span class="keywordtype">int</span> A2[5] = {1, 3, 5, 7, 9};

  <span class="keywordtype">int</span> result[11];

  <span class="keywordtype">int</span> *result_end = <a class="code" href="group__set__operations.html#ga7fb6690a07e030091851eeff23a2f93a">thrust::set_union</a>(A1, A1 + 6, A2, A2 + 5, result);
  <span class="comment">// result = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12}</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/set_union.html">http://www.sgi.com/tech/stl/set_union.html</a> </dd>
<dd>
<code><a class="el" href="group__merging.html#ga91d42e699631de9f7647090c91eadf7a">merge</a></code> </dd>
<dd>
<code>includes</code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga7fb6690a07e030091851eeff23a2f93a">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga17277fec1491c8a916c9908a5ae40807">set_intersection</a></code> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga2a6e7275fd83a3079804d143542c7b17">set_symmetric_difference</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga8fd4df95e8e16c89ff92737947daa1f9">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#gadb8e5879d64546addb3b252c214e3bea">is_sorted</a></code> </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon May 7 2012 15:15:01 for thrust by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
