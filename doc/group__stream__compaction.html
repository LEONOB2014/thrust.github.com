<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>thrust: Stream Compaction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">thrust</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Stream Compaction</div>  </div>
<div class="ingroups"><a class="el" href="group__reordering.html">Reordering</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga59ae90883860b391cec33e13e73fece3">thrust::copy_if</a> (InputIterator first, InputIterator last, OutputIterator result, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gab6f762b3382ab3a5bcb891394f8a818b">thrust::copy_if</a> (InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator result, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gaee39ef07b42f5d17b453e409f7f9b315">thrust::remove</a> (ForwardIterator first, ForwardIterator last, const T &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gae94994f9049c44a4298dcf2c6ceb2514">thrust::remove_copy</a> (InputIterator first, InputIterator last, OutputIterator result, const T &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga517b17ceafe31a9fc70ac5127bd626de">thrust::remove_if</a> (ForwardIterator first, ForwardIterator last, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga0dd1a702821e89b3369c7ae0d3f45af7">thrust::remove_copy_if</a> (InputIterator first, InputIterator last, OutputIterator result, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename InputIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga5760a32d1a99d89732206f48b75138ea">thrust::remove_if</a> (ForwardIterator first, ForwardIterator last, InputIterator stencil, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga0779d9d2b8a76305ca853bb1a70c7c52">thrust::remove_copy_if</a> (InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator result, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga330c12555aa9d382254c9f1296e3edcc">thrust::unique</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gaa213c713ba882275d7f98564528bc4ab">thrust::unique</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gae039017ffdee9a60fcb23e6c378ef0d6">thrust::unique_copy</a> (InputIterator first, InputIterator last, OutputIterator output)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga59a7948ed24d06d3848d5ae3a087f062">thrust::unique_copy</a> (InputIterator first, InputIterator last, OutputIterator output, BinaryPredicate binary_pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator1 , typename ForwardIterator2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; ForwardIterator1, <br class="typebreak"/>
ForwardIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga58de173e7dffb56eec2aecf3c533559f">thrust::unique_by_key</a> (ForwardIterator1 keys_first, ForwardIterator1 keys_last, ForwardIterator2 values_first)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator1 , typename ForwardIterator2 , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; ForwardIterator1, <br class="typebreak"/>
ForwardIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gadc7b26c12fa96f449f17d7c1da3e24bd">thrust::unique_by_key</a> (ForwardIterator1 keys_first, ForwardIterator1 keys_last, ForwardIterator2 values_first, BinaryPredicate binary_pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator1 , typename OutputIterator2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gaac7ed61a13a6c19ba636263fac91131d">thrust::unique_by_key_copy</a> (InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator1 , typename OutputIterator2 , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga361958a1440786235d2561b66db5de57">thrust::unique_by_key_copy</a> (InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>// end copying </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga59ae90883860b391cec33e13e73fece3"></a><!-- doxytag: member="thrust::copy_if" ref="ga59ae90883860b391cec33e13e73fece3" args="(InputIterator first, InputIterator last, OutputIterator result, Predicate pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This version of <code>copy_if</code> copies elements from the range <code>[first,last)</code> to a range beginning at \ presult, except that any element which causes <code>pred</code> to be <code>pred</code> to be <code>false</code> is not copied.</p>
<p>More precisely, for every integer <code>n</code> such that <code>0 &lt;= n &lt; last-first</code>, <code>copy_if</code> performs the assignment <code>*result = *(first+n)</code> and <code>result</code> is advanced one position if <code>pred(*(first+n))</code>. Otherwise, no assignment occurs and <code>result</code> is not advanced.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the sequence from which to copy. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the sequence from which to copy. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the sequence into which to copy. </td></tr>
    <tr><td class="paramname">pred</td><td>The predicate to test on every value of the range <code>[first, last)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>result + n</code>, where <code>n</code> is equal to the number of times <code>pred</code> evaluated to <code>true</code> in the range <code>[first, last)</code>.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>Predicate's</code> <code>argument_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">Predicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>copy_if</code> to perform stream compaction to copy even numbers to an output range.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="copy_8h.html" title="Copies elements from one range to another.">thrust/copy.h</a>&gt;</span>
  ...
  <span class="keyword">struct </span>is_even
  {
    __host__ __device__
    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <span class="keywordtype">int</span> x)
    {
      <span class="keywordflow">return</span> (x % 2) == 0;
    }
  };
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 6;
  <span class="keywordtype">int</span> V[N] = {-2, 0, -1, 0, 1, 2};
  <span class="keywordtype">int</span> result[4];

  <a class="code" href="group__stream__compaction.html#ga59ae90883860b391cec33e13e73fece3">thrust::copy_if</a>(V, V + N, result, is_even());

  <span class="comment">// V remains {-2, 0, -1, 0, 1, 2}</span>
  <span class="comment">// result is now {-2, 0, 0, 2}</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><code><a class="el" href="group__stream__compaction.html#ga0dd1a702821e89b3369c7ae0d3f45af7">remove_copy_if</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="gab6f762b3382ab3a5bcb891394f8a818b"></a><!-- doxytag: member="thrust::copy_if" ref="gab6f762b3382ab3a5bcb891394f8a818b" args="(InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator result, Predicate pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>stencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This version of <code>copy_if</code> copies elements from the range <code>[first,last)</code> to a range beginning at <code>result</code>, except that any element whose corresponding stencil element causes <code>pred</code> to be <code>false</code> is not copied.</p>
<p>More precisely, for every integer <code>n</code> such that <code>0 &lt;= n &lt; last-first</code>, <code>copy_if</code> performs the assignment <code>*result = *(first+n)</code> and <code>result</code> is advanced one position if <code>pred(*(stencil+n))</code>. Otherwise, no assignment occurs and <code>result</code> is not advanced.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the sequence from which to copy. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the sequence from which to copy. </td></tr>
    <tr><td class="paramname">stencil</td><td>The beginning of the stencil sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the sequence into which to copy. </td></tr>
    <tr><td class="paramname">pred</td><td>The predicate to test on every value of the range <code>[stencil, stencil + (last-first))</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>result + n</code>, where <code>n</code> is equal to the number of times <code>pred</code> evaluated to <code>true</code> in the range <code>[stencil, stencil + (last-first))</code>.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator2's</code> <code>value_type</code> is convertible to <code>Predicate's</code> <code>argument_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">Predicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>copy_if</code> to perform stream compaction to copy numbers to an output range when corresponding stencil elements are even:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="copy_8h.html" title="Copies elements from one range to another.">thrust/copy.h</a>&gt;</span>
  ...
  <span class="keyword">struct </span>is_even
  {
    __host__ __device__
    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <span class="keywordtype">int</span> x)
    {
      <span class="keywordflow">return</span> (x % 2) == 0;
    }
  };
  ...
  <span class="keywordtype">int</span> N = 6;
  <span class="keywordtype">int</span> data[N]    = { 0, 1,  2, 3, 4, 5};
  <span class="keywordtype">int</span> stencil[N] = {-2, 0, -1, 0, 1, 2};
  <span class="keywordtype">int</span> result[4];

  <a class="code" href="group__stream__compaction.html#ga59ae90883860b391cec33e13e73fece3">thrust::copy_if</a>(data, data + N, stencil, result, is_even());

  <span class="comment">// data remains    = { 0, 1,  2, 3, 4, 5};</span>
  <span class="comment">// stencil remains = {-2, 0, -1, 0, 1, 2};</span>
  <span class="comment">// result is now     { 0, 1,  3, 5}</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><code><a class="el" href="group__stream__compaction.html#ga0dd1a702821e89b3369c7ae0d3f45af7">remove_copy_if</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="gaee39ef07b42f5d17b453e409f7f9b315"></a><!-- doxytag: member="thrust::remove" ref="gaee39ef07b42f5d17b453e409f7f9b315" args="(ForwardIterator first, ForwardIterator last, const T &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator thrust::remove </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>remove</code> removes from the range <code>[first, last)</code> all elements that are equal to <code>value</code>. That is, <code>remove</code> returns an iterator <code>new_last</code> such that the range <code>[first, new_last)</code> contains no elements equal to <code>value</code>. The iterators in the range <code>[new_first,last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>remove</code> is stable, meaning that the relative order of elements that are not equal to <code>value</code> is unchanged.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range of interest. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range of interest. </td></tr>
    <tr><td class="paramname">value</td><td>The value to remove from the range <code>[first, last)</code>. Elements which are equal to value are removed from the sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>ForwardIterator</code> pointing to the end of the resulting range of elements which are not equal to <code>value</code>.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">ForwardIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/ForwardIterator.html">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable. </td></tr>
    <tr><td class="paramname">T</td><td>is a model of <a href="http://www.sgi.com/tech/stl/EqualityComparable.html">Equality Comparable</a>, and objects of type <code>T</code> can be compared for equality with objects of <code>ForwardIterator's</code> <code>value_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>remove</code> to remove a number of interest from a range.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="remove_8h.html" title="Functions for removing elements from a range.">thrust/remove.h</a>&gt;</span>
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 6;
  <span class="keywordtype">int</span> A[N] = {3, 1, 4, 1, 5, 9};
  <span class="keywordtype">int</span> *new_end = <a class="code" href="group__stream__compaction.html#gaee39ef07b42f5d17b453e409f7f9b315">thrust::remove</a>(A, A + N, 1);
  <span class="comment">// The first four values of A are now {3, 4, 5, 9}</span>
  <span class="comment">// Values beyond new_end are unspecified</span>
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>The meaning of "removal" is somewhat subtle. <code>remove</code> does not destroy any iterators, and does not change the distance between <code>first</code> and <code>last</code>. (There's no way that it could do anything of the sort.) So, for example, if <code>V</code> is a <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>, <code>remove(V.begin(), V.end(), 0)</code> does not change <code>V.size()</code>: <code>V</code> will contain just as many elements as it did before. <code>remove</code> returns an iterator that points to the end of the resulting range after elements have been removed from it; it follows that the elements after that iterator are of no interest, and may be discarded. If you are removing elements from a <a href="http://www.sgi.com/tech/stl/Sequence.html">Sequence</a>, you may simply erase them. That is, a reasonable way of removing elements from a <a href="http://www.sgi.com/tech/stl/Sequence.html">Sequence</a> is <code>S.erase(remove(S.begin(), S.end(), x), S.end())</code>.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/remove.html">http://www.sgi.com/tech/stl/remove.html</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#ga517b17ceafe31a9fc70ac5127bd626de">remove_if</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#gae94994f9049c44a4298dcf2c6ceb2514">remove_copy</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#ga0dd1a702821e89b3369c7ae0d3f45af7">remove_copy_if</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae94994f9049c44a4298dcf2c6ceb2514"></a><!-- doxytag: member="thrust::remove_copy" ref="gae94994f9049c44a4298dcf2c6ceb2514" args="(InputIterator first, InputIterator last, OutputIterator result, const T &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::remove_copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>remove_copy</code> copies elements that are not equal to <code>value</code> from the range <code>[first, last)</code> to a range beginning at <code>result</code>. The return value is the end of the resulting range. This operation is stable, meaning that the relative order of the elements that are copied is the same as in the range <code>[first, last)</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range of interest. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range of interest. </td></tr>
    <tr><td class="paramname">result</td><td>The resulting range is copied to the sequence beginning at this location. </td></tr>
    <tr><td class="paramname">value</td><td>The value to omit from the copied range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An OutputIterator pointing to the end of the resulting range of elements which are not equal to <code>value</code>.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">T</td><td>is a model of <a href="http://www.sgi.com/tech/stl/EqualityComparable">Equality Comparable</a>, and objects of type <code>T</code> can be compared for equality with objects of <code>InputIterator's</code> <code>value_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>remove_copy</code> to copy a sequence of numbers to an output range while omitting a value of interest.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="remove_8h.html" title="Functions for removing elements from a range.">thrust/remove.h</a>&gt;</span>
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 6;
  <span class="keywordtype">int</span> V[N] = {-2, 0, -1, 0, 1, 2};
  <span class="keywordtype">int</span> result[N-2];
  <a class="code" href="group__stream__compaction.html#gae94994f9049c44a4298dcf2c6ceb2514">thrust::remove_copy</a>(V, V + N, result, 0);
  <span class="comment">// V remains {-2, 0, -1, 0, 1, 2}</span>
  <span class="comment">// result is now {-2, -1, 1, 2}</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/remove_copy.html">http://www.sgi.com/tech/stl/remove_copy.html</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#gaee39ef07b42f5d17b453e409f7f9b315">remove</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#ga517b17ceafe31a9fc70ac5127bd626de">remove_if</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#ga0dd1a702821e89b3369c7ae0d3f45af7">remove_copy_if</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0779d9d2b8a76305ca853bb1a70c7c52"></a><!-- doxytag: member="thrust::remove_copy_if" ref="ga0779d9d2b8a76305ca853bb1a70c7c52" args="(InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator result, Predicate pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::remove_copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>stencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>remove_copy_if</code> copies elements from the range <code>[first,last)</code> to a range beginning at <code>result</code>, except that elements for which <code>pred</code> of the corresponding stencil value is <code>true</code> are not copied. The return value is the end of the resulting range. This operation is stable, meaning that the relative order of the elements that are copied is the same as the range <code>[first,last)</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range of interest. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range of interest. </td></tr>
    <tr><td class="paramname">stencil</td><td>The beginning of the stencil sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The resulting range is copied to the sequence beginning at this location. </td></tr>
    <tr><td class="paramname">pred</td><td>A predicate to evaluate for each element of the range <code>[first,last)</code>. Elements for which <code>pred</code> evaluates to <code>false</code> are not copied to the resulting sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An OutputIterator pointing to the end of the resulting range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator2's</code> <code>value_type</code> is convertible to <code>Predicate's</code> <code>argument_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">Predicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>remove_copy_if</code> to copy a sequence of numbers to an output range while omitting specific elements.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="remove_8h.html" title="Functions for removing elements from a range.">thrust/remove.h</a>&gt;</span>
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 6;
  <span class="keywordtype">int</span> V[N] = {-2, 0, -1, 0, 1, 2};
  <span class="keywordtype">int</span> S[N] = { 1, 1,  0, 1, 0, 1};
  <span class="keywordtype">int</span> result[2];
  <a class="code" href="group__stream__compaction.html#ga0dd1a702821e89b3369c7ae0d3f45af7">thrust::remove_copy_if</a>(V, V + N, S, result, <a class="code" href="structthrust_1_1identity.html">thrust::identity&lt;int&gt;</a>());
  <span class="comment">// V remains {-2, 0, -1, 0, 1, 2}</span>
  <span class="comment">// result is now {-1, 1}</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/remove_copy_if.html">http://www.sgi.com/tech/stl/remove_copy_if.html</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#gaee39ef07b42f5d17b453e409f7f9b315">remove</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#gae94994f9049c44a4298dcf2c6ceb2514">remove_copy</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#ga517b17ceafe31a9fc70ac5127bd626de">remove_if</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#ga59ae90883860b391cec33e13e73fece3">copy_if</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0dd1a702821e89b3369c7ae0d3f45af7"></a><!-- doxytag: member="thrust::remove_copy_if" ref="ga0dd1a702821e89b3369c7ae0d3f45af7" args="(InputIterator first, InputIterator last, OutputIterator result, Predicate pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::remove_copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>remove_copy_if</code> copies elements from the range <code>[first,last)</code> to a range beginning at <code>result</code>, except that elements for which <code>pred</code> is <code>true</code> are not copied. The return value is the end of the resulting range. This operation is stable, meaning that the relative order of the elements that are copied is the same as the range <code>[first,last)</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range of interest. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range of interest. </td></tr>
    <tr><td class="paramname">result</td><td>The resulting range is copied to the sequence beginning at this location. </td></tr>
    <tr><td class="paramname">pred</td><td>A predicate to evaluate for each element of the range <code>[first,last)</code>. Elements for which <code>pred</code> evaluates to <code>false</code> are not copied to the resulting sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An OutputIterator pointing to the end of the resulting range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value_types</code>, and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>Predicate's</code> <code>argument_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">Predicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>remove_copy_if</code> to copy a sequence of numbers to an output range while omitting even numbers.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="remove_8h.html" title="Functions for removing elements from a range.">thrust/remove.h</a>&gt;</span>
  ...
  <span class="keyword">struct </span>is_even
  {
    __host__ __device__
    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <span class="keywordtype">int</span> x)
    {
      <span class="keywordflow">return</span> (x % 2) == 0;
    }
  };
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 6;
  <span class="keywordtype">int</span> V[N] = {-2, 0, -1, 0, 1, 2};
  <span class="keywordtype">int</span> result[2];
  <a class="code" href="group__stream__compaction.html#ga0dd1a702821e89b3369c7ae0d3f45af7">thrust::remove_copy_if</a>(V, V + N, result, is_even());
  <span class="comment">// V remains {-2, 0, -1, 0, 1, 2}</span>
  <span class="comment">// result is now {-1, 1}</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/remove_copy_if.html">http://www.sgi.com/tech/stl/remove_copy_if.html</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#gaee39ef07b42f5d17b453e409f7f9b315">remove</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#gae94994f9049c44a4298dcf2c6ceb2514">remove_copy</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#ga517b17ceafe31a9fc70ac5127bd626de">remove_if</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga517b17ceafe31a9fc70ac5127bd626de"></a><!-- doxytag: member="thrust::remove_if" ref="ga517b17ceafe31a9fc70ac5127bd626de" args="(ForwardIterator first, ForwardIterator last, Predicate pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator thrust::remove_if </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>remove_if</code> removes from the range <code>[first, last)</code> every element <code>x</code> such that <code>pred(x)</code> is <code>true</code>. That is, <code>remove_if</code> returns an iterator <code>new_last</code> such that the range <code>[first,new_last)</code> contains no elements for which <code>pred</code> is <code>true</code>. The iterators in the range <code>[new_last,last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>remove_if</code> is stable, meaning that the relative order of elements that are not removed is unchanged.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range of interest. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range of interest. </td></tr>
    <tr><td class="paramname">pred</td><td>A predicate to evaluate for each element of the range <code>[first,last)</code>. Elements for which <code>pred</code> evaluates to <code>false</code> are removed from the sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A ForwardIterator pointing to the end of the resulting range of elements for which <code>pred</code> evaluated to <code>true</code>.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">ForwardIterator</td><td>is a model of <a href="http://www.sgi.com/tech/ForwardIterator.html">Forward Iterator</a>, <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code> <code>value_type</code> is convertible to <code>Predicate's</code> <code>argument_type</code>. </td></tr>
    <tr><td class="paramname">Predicate</td><td>is a model of <a href="http://www.sgi.com/tech/Predicate.html">Predicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>remove_if</code> to remove all even numbers from an array of integers.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="remove_8h.html" title="Functions for removing elements from a range.">thrust/remove.h</a>&gt;</span>
  ...
  <span class="keyword">struct </span>is_even
  {
    __host__ __device__
    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <span class="keywordtype">int</span> x)
    {
      <span class="keywordflow">return</span> (x % 2) == 0;
    }
  };
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 6;
  <span class="keywordtype">int</span> A[N] = {1, 4, 2, 8, 5, 7};
  <span class="keywordtype">int</span> *new_end = <a class="code" href="group__stream__compaction.html#ga517b17ceafe31a9fc70ac5127bd626de">thrust::remove_if</a>(A, A + N, is_even());
  <span class="comment">// The first three values of A are now {1, 5, 7}</span>
  <span class="comment">// Values beyond new_end are unspecified</span>
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>The meaning of "removal" is somewhat subtle. <code>remove_if</code> does not destroy any iterators, and does not change the distance between <code>first</code> and <code>last</code>. (There's no way that it could do anything of the sort.) So, for example, if <code>V</code> is a <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>, <code>remove_if(V.begin(), V.end(), pred)</code> does not change <code>V.size()</code>: <code>V</code> will contain just as many elements as it did before. <code>remove_if</code> returns an iterator that points to the end of the resulting range after elements have been removed from it; it follows that the elements after that iterator are of no interest, and may be discarded. If you are removing elements from a <a href="http://www.sgi.com/tech/stl/Sequence.html">Sequence</a>, you may simply erase them. That is, a reasonable way of removing elements from a <a href="http://www.sgi.com/tech/stl/Sequence.html">Sequence</a> is <code>S.erase(remove_if(S.begin(), S.end(), pred), S.end())</code>.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/remove_if.html">http://www.sgi.com/tech/stl/remove_if.html</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#gaee39ef07b42f5d17b453e409f7f9b315">remove</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#gae94994f9049c44a4298dcf2c6ceb2514">remove_copy</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#ga0dd1a702821e89b3369c7ae0d3f45af7">remove_copy_if</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5760a32d1a99d89732206f48b75138ea"></a><!-- doxytag: member="thrust::remove_if" ref="ga5760a32d1a99d89732206f48b75138ea" args="(ForwardIterator first, ForwardIterator last, InputIterator stencil, Predicate pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename InputIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator thrust::remove_if </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>stencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>remove_if</code> removes from the range <code>[first, last)</code> every element <code>x</code> such that <code>pred(x)</code> is <code>true</code>. That is, <code>remove_if</code> returns an iterator <code>new_last</code> such that the range <code>[first, new_last)</code> contains no elements for which <code>pred</code> of the corresponding stencil value is <code>true</code>. The iterators in the range <code>[new_last,last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>remove_if</code> is stable, meaning that the relative order of elements that are not removed is unchanged.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range of interest. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range of interest. </td></tr>
    <tr><td class="paramname">stencil</td><td>The beginning of the stencil sequence. </td></tr>
    <tr><td class="paramname">pred</td><td>A predicate to evaluate for each element of the range <code>[stencil, stencil + (last - first))</code>. Elements for which <code>pred</code> evaluates to <code>false</code> are removed from the sequence <code>[first, last)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A ForwardIterator pointing to the end of the resulting range of elements for which <code>pred</code> evaluated to <code>true</code>.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">ForwardIterator</td><td>is a model of <a href="http://www.sgi.com/tech/ForwardIterator.html">Forward Iterator</a> and <code>ForwardIterator</code> is mutable. </td></tr>
    <tr><td class="paramname">InputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>Predicate's</code> <code>argument_type</code>. </td></tr>
    <tr><td class="paramname">Predicate</td><td>is a model of <a href="http://www.sgi.com/tech/Predicate.html">Predicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>remove_if</code> to remove specific elements from an array of integers.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="remove_8h.html" title="Functions for removing elements from a range.">thrust/remove.h</a>&gt;</span>
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 6;
  <span class="keywordtype">int</span> A[N] = {1, 4, 2, 8, 5, 7};
  <span class="keywordtype">int</span> S[N] = {0, 1, 1, 1, 0, 0};

  <span class="keywordtype">int</span> *new_end = <a class="code" href="group__stream__compaction.html#gaee39ef07b42f5d17b453e409f7f9b315">thrust::remove</a>(A, A + N, S, <a class="code" href="structthrust_1_1identity.html">thrust::identity&lt;int&gt;</a>());
  <span class="comment">// The first three values of A are now {1, 5, 7}</span>
  <span class="comment">// Values beyond new_end are unspecified</span>
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>The range <code>[first, last)</code> is not permitted to overlap with the range <code>[stencil, stencil + (last - first))</code>.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/remove_if.html">http://www.sgi.com/tech/stl/remove_if.html</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#gaee39ef07b42f5d17b453e409f7f9b315">remove</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#gae94994f9049c44a4298dcf2c6ceb2514">remove_copy</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#ga0dd1a702821e89b3369c7ae0d3f45af7">remove_copy_if</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga330c12555aa9d382254c9f1296e3edcc"></a><!-- doxytag: member="thrust::unique" ref="ga330c12555aa9d382254c9f1296e3edcc" args="(ForwardIterator first, ForwardIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator thrust::unique </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each group of consecutive elements in the range <code>[first, last)</code> with the same value, <code>unique</code> removes all but the first element of the group. The return value is an iterator <code>new_last</code> such that no two consecutive elements in the range <code>[first, new_last)</code> are equal. The iterators in the range <code>[new_last, last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>unique</code> is stable, meaning that the relative order of elements that are not removed is unchanged.</p>
<p>This version of <code>unique</code> uses <code>operator==</code> to test for equality.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the input range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the input range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the unique range <code>[first, new_last)</code>.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">ForwardIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/ForwardIterator.html">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/EqualityComparable.html">Equality Comparable</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>unique</code> to compact a sequence of numbers to remove consecutive duplicates.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="unique_8h.html" title="Move unique elements to the front of a range.">thrust/unique.h</a>&gt;</span>
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 7;
  <span class="keywordtype">int</span> A[N] = {1, 3, 3, 3, 2, 2, 1};
  <span class="keywordtype">int</span> *new_end = <a class="code" href="group__stream__compaction.html#ga330c12555aa9d382254c9f1296e3edcc">thrust::unique</a>(A, A + N);
  <span class="comment">// The first four values of A are now {1, 3, 2, 1}</span>
  <span class="comment">// Values beyond new_end are unspecified.</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/unique.html">http://www.sgi.com/tech/stl/unique.html</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#gae039017ffdee9a60fcb23e6c378ef0d6">unique_copy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa213c713ba882275d7f98564528bc4ab"></a><!-- doxytag: member="thrust::unique" ref="gaa213c713ba882275d7f98564528bc4ab" args="(ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator thrust::unique </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each group of consecutive elements in the range <code>[first, last)</code> with the same value, <code>unique</code> removes all but the first element of the group. The return value is an iterator <code>new_last</code> such that no two consecutive elements in the range <code>[first, new_last)</code> are equal. The iterators in the range <code>[new_last, last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>unique</code> is stable, meaning that the relative order of elements that are not removed is unchanged.</p>
<p>This version of <code>unique</code> uses the function object <code>binary_pred</code> to test for equality.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the input range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the input range. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>The binary predicate used to determine equality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the unique range <code>[first, new_last)</code></dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">ForwardIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/ForwardIterator.html">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code> <code>value_type</code> is convertible to <code>BinaryPredicate's</code> <code>first_argument_type</code> and to <code>BinaryPredicate's</code> <code>second_argument_type</code>. </td></tr>
    <tr><td class="paramname">BinaryPredicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">Binary Predicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>unique</code> to compact a sequence of numbers to remove consecutive duplicates.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="unique_8h.html" title="Move unique elements to the front of a range.">thrust/unique.h</a>&gt;</span>
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 7;
  <span class="keywordtype">int</span> A[N] = {1, 3, 3, 3, 2, 2, 1};
  <span class="keywordtype">int</span> *new_end = <a class="code" href="group__stream__compaction.html#ga330c12555aa9d382254c9f1296e3edcc">thrust::unique</a>(A, A + N, <a class="code" href="structthrust_1_1equal__to.html">thrust::equal_to&lt;int&gt;</a>());
  <span class="comment">// The first four values of A are now {1, 3, 2, 1}</span>
  <span class="comment">// Values beyond new_end are unspecified.</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/unique.html">http://www.sgi.com/tech/stl/unique.html</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#gae039017ffdee9a60fcb23e6c378ef0d6">unique_copy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadc7b26c12fa96f449f17d7c1da3e24bd"></a><!-- doxytag: member="thrust::unique_by_key" ref="gadc7b26c12fa96f449f17d7c1da3e24bd" args="(ForwardIterator1 keys_first, ForwardIterator1 keys_last, ForwardIterator2 values_first, BinaryPredicate binary_pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator1 , typename ForwardIterator2 , typename BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;ForwardIterator1,ForwardIterator2&gt; thrust::unique_by_key </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>keys_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>values_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>unique_by_key</code> is a generalization of <code>unique</code> to key-value pairs. For each group of consecutive keys in the range <code>[keys_first, keys_last)</code> that are equal, <code>unique_by_key</code> removes all but the first element of the group. Similarly, the corresponding values in the range <code>[values_first, values_first + (keys_last - keys_first))</code> are also removed.</p>
<p>This version of <code>unique_by_key</code> uses the function object <code>binary_pred</code> to test for equality and <code><a class="el" href="structthrust_1_1project1st.html">project1st</a></code> to reduce values with equal keys.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">keys_first</td><td>The beginning of the key range. </td></tr>
    <tr><td class="paramname">keys_last</td><td>The end of the key range. </td></tr>
    <tr><td class="paramname">values_first</td><td>The beginning of the value range. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>The binary predicate used to determine equality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the unique range <code>[first, new_last)</code>.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">ForwardIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/ForwardIterator.html">Forward Iterator</a>, and <code>ForwardIterator1</code> is mutable, and <code>ForwardIterator's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/EqualityComparable.html">Equality Comparable</a>. </td></tr>
    <tr><td class="paramname">ForwardIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/ForwardIterator.html">Forward Iterator</a>, and <code>ForwardIterator2</code> is mutable. </td></tr>
    <tr><td class="paramname">BinaryPredicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">Binary Predicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>unique_by_key</code> to compact a sequence of key/value pairs to remove consecutive duplicates.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="unique_8h.html" title="Move unique elements to the front of a range.">thrust/unique.h</a>&gt;</span>
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 7;
  <span class="keywordtype">int</span> A[N] = {1, 3, 3, 3, 2, 2, 1}; <span class="comment">// keys</span>
  <span class="keywordtype">int</span> B[N] = {9, 8, 7, 6, 5, 4, 3}; <span class="comment">// values</span>

  <a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> new_end;
  <a class="code" href="structthrust_1_1equal__to.html">thrust::equal_to&lt;int&gt;</a> binary_pred;
  new_end = <a class="code" href="group__stream__compaction.html#ga58de173e7dffb56eec2aecf3c533559f">thrust::unique_by_key</a>(keys, keys + N, values, binary_pred);

  <span class="comment">// The first four keys in A are now {1, 3, 2, 1} and new_end.first - A is 4.</span>
  <span class="comment">// The first four values in B are now {9, 8, 5, 3} and new_end.second - B is 4.</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__stream__compaction.html#ga330c12555aa9d382254c9f1296e3edcc">unique</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#gaac7ed61a13a6c19ba636263fac91131d">unique_by_key_copy</a> </dd>
<dd>
<a class="el" href="group__reductions.html#gac1fadcdd29791f655a3144c2e741838a">reduce_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga58de173e7dffb56eec2aecf3c533559f"></a><!-- doxytag: member="thrust::unique_by_key" ref="ga58de173e7dffb56eec2aecf3c533559f" args="(ForwardIterator1 keys_first, ForwardIterator1 keys_last, ForwardIterator2 values_first)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator1 , typename ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;ForwardIterator1,ForwardIterator2&gt; thrust::unique_by_key </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>keys_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>values_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>unique_by_key</code> is a generalization of <code>unique</code> to key-value pairs. For each group of consecutive keys in the range <code>[keys_first, keys_last)</code> that are equal, <code>unique_by_key</code> removes all but the first element of the group. Similarly, the corresponding values in the range <code>[values_first, values_first + (keys_last - keys_first))</code> are also removed.</p>
<p>The return value is a <code>pair</code> of iterators <code>(new_keys_last,new_values_last)</code> such that no two consecutive elements in the range <code>[keys_first, new_keys_last)</code> are equal.</p>
<p>This version of <code>unique_by_key</code> uses <code>operator==</code> to test for equality and <code><a class="el" href="structthrust_1_1project1st.html">project1st</a></code> to reduce values with equal keys.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">keys_first</td><td>The beginning of the key range. </td></tr>
    <tr><td class="paramname">keys_last</td><td>The end of the key range. </td></tr>
    <tr><td class="paramname">values_first</td><td>The beginning of the value range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pair of iterators at end of the ranges <code>[key_first, keys_new_last)</code> and <code>[values_first, values_new_last)</code>.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">ForwardIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/ForwardIterator.html">Forward Iterator</a>, and <code>ForwardIterator1</code> is mutable, and <code>ForwardIterator's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/EqualityComparable.html">Equality Comparable</a>. </td></tr>
    <tr><td class="paramname">ForwardIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/ForwardIterator.html">Forward Iterator</a>, and <code>ForwardIterator2</code> is mutable.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>unique_by_key</code> to compact a sequence of key/value pairs to remove consecutive duplicates.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="unique_8h.html" title="Move unique elements to the front of a range.">thrust/unique.h</a>&gt;</span>
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 7;
  <span class="keywordtype">int</span> A[N] = {1, 3, 3, 3, 2, 2, 1}; <span class="comment">// keys</span>
  <span class="keywordtype">int</span> B[N] = {9, 8, 7, 6, 5, 4, 3}; <span class="comment">// values</span>

  <a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> new_end;
  new_end = <a class="code" href="group__stream__compaction.html#ga58de173e7dffb56eec2aecf3c533559f">thrust::unique_by_key</a>(A, A + N, B);

  <span class="comment">// The first four keys in A are now {1, 3, 2, 1} and new_end.first - A is 4.</span>
  <span class="comment">// The first four values in B are now {9, 8, 5, 3} and new_end.second - B is 4.</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__stream__compaction.html#ga330c12555aa9d382254c9f1296e3edcc">unique</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#gaac7ed61a13a6c19ba636263fac91131d">unique_by_key_copy</a> </dd>
<dd>
<a class="el" href="group__reductions.html#gac1fadcdd29791f655a3144c2e741838a">reduce_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga361958a1440786235d2561b66db5de57"></a><!-- doxytag: member="thrust::unique_by_key_copy" ref="ga361958a1440786235d2561b66db5de57" args="(InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator1 , typename OutputIterator2 , typename BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::unique_by_key_copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>values_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>unique_by_key_copy</code> is a generalization of <code>unique_copy</code> to key-value pairs. For each group of consecutive keys in the range <code>[keys_first, keys_last)</code> that are equal, <code>unique_by_key_copy</code> copies the first element of the group to a range beginning with <code>keys_output</code> and the corresponding values from the range <code>[values_first, values_first + (keys_last - keys_first))</code> are copied to a range beginning with <code>values_output</code>.</p>
<p>This version of <code>unique_by_key_copy</code> uses the function object <code>binary_pred</code> to test for equality and <code><a class="el" href="structthrust_1_1project1st.html">project1st</a></code> to reduce values with equal keys.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">keys_first</td><td>The beginning of the input key range. </td></tr>
    <tr><td class="paramname">keys_last</td><td>The end of the input key range. </td></tr>
    <tr><td class="paramname">values_first</td><td>The beginning of the input value range. </td></tr>
    <tr><td class="paramname">keys_output</td><td>The beginning of the output key range. </td></tr>
    <tr><td class="paramname">values_output</td><td>The beginning of the output value range. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>The binary predicate used to determine equality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pair of iterators at end of the ranges <code>[keys_output, keys_output_last)</code> and <code>[values_output, values_output_last)</code>.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a> and and <code>InputIterator1's</code> <code>value_type</code> is convertible to <code>OutputIterator1's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a> and and <code>InputIterator2's</code> <code>value_type</code> is convertible to <code>OutputIterator2's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">BinaryPredicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">Binary Predicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>unique_by_key_copy</code> to compact a sequence of key/value pairs and with equal keys.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="unique_8h.html" title="Move unique elements to the front of a range.">thrust/unique.h</a>&gt;</span>
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 7;
  <span class="keywordtype">int</span> A[N] = {1, 3, 3, 3, 2, 2, 1}; <span class="comment">// input keys</span>
  <span class="keywordtype">int</span> B[N] = {9, 8, 7, 6, 5, 4, 3}; <span class="comment">// input values</span>
  <span class="keywordtype">int</span> C[N];                         <span class="comment">// output keys</span>
  <span class="keywordtype">int</span> D[N];                         <span class="comment">// output values</span>

  <a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> new_end;
  <a class="code" href="structthrust_1_1equal__to.html">thrust::equal_to&lt;int&gt;</a> binary_pred;
  new_end = <a class="code" href="group__stream__compaction.html#gaac7ed61a13a6c19ba636263fac91131d">thrust::unique_by_key_copy</a>(A, A + N, B, C, D, binary_pred);

  <span class="comment">// The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.</span>
  <span class="comment">// The first four values in D are now {9, 8, 5, 3} and new_end.second - D is 4.</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__stream__compaction.html#gae039017ffdee9a60fcb23e6c378ef0d6">unique_copy</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#ga58de173e7dffb56eec2aecf3c533559f">unique_by_key</a> </dd>
<dd>
<a class="el" href="group__reductions.html#gac1fadcdd29791f655a3144c2e741838a">reduce_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaac7ed61a13a6c19ba636263fac91131d"></a><!-- doxytag: member="thrust::unique_by_key_copy" ref="gaac7ed61a13a6c19ba636263fac91131d" args="(InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator1 , typename OutputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::unique_by_key_copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>values_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>unique_by_key_copy</code> is a generalization of <code>unique_copy</code> to key-value pairs. For each group of consecutive keys in the range <code>[keys_first, keys_last)</code> that are equal, <code>unique_by_key_copy</code> copies the first element of the group to a range beginning with <code>keys_output</code> and the corresponding values from the range <code>[values_first, values_first + (keys_last - keys_first))</code> are copied to a range beginning with <code>values_output</code>.</p>
<p>This version of <code>unique_by_key_copy</code> uses <code>operator==</code> to test for equality and <code><a class="el" href="structthrust_1_1project1st.html">project1st</a></code> to reduce values with equal keys.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">keys_first</td><td>The beginning of the input key range. </td></tr>
    <tr><td class="paramname">keys_last</td><td>The end of the input key range. </td></tr>
    <tr><td class="paramname">values_first</td><td>The beginning of the input value range. </td></tr>
    <tr><td class="paramname">keys_output</td><td>The beginning of the output key range. </td></tr>
    <tr><td class="paramname">values_output</td><td>The beginning of the output value range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pair of iterators at end of the ranges <code>[keys_output, keys_output_last)</code> and <code>[values_output, values_output_last)</code>.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a> and and <code>InputIterator1's</code> <code>value_type</code> is convertible to <code>OutputIterator1's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a> and and <code>InputIterator2's</code> <code>value_type</code> is convertible to <code>OutputIterator2's</code> <code>value_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>unique_by_key_copy</code> to compact a sequence of key/value pairs and with equal keys.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="unique_8h.html" title="Move unique elements to the front of a range.">thrust/unique.h</a>&gt;</span>
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 7;
  <span class="keywordtype">int</span> A[N] = {1, 3, 3, 3, 2, 2, 1}; <span class="comment">// input keys</span>
  <span class="keywordtype">int</span> B[N] = {9, 8, 7, 6, 5, 4, 3}; <span class="comment">// input values</span>
  <span class="keywordtype">int</span> C[N];                         <span class="comment">// output keys</span>
  <span class="keywordtype">int</span> D[N];                         <span class="comment">// output values</span>

  <a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> new_end;
  new_end = <a class="code" href="group__stream__compaction.html#gaac7ed61a13a6c19ba636263fac91131d">thrust::unique_by_key_copy</a>(A, A + N, B, C, D);

  <span class="comment">// The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.</span>
  <span class="comment">// The first four values in D are now {9, 8, 5, 3} and new_end.second - D is 4.</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__stream__compaction.html#gae039017ffdee9a60fcb23e6c378ef0d6">unique_copy</a> </dd>
<dd>
<a class="el" href="group__stream__compaction.html#ga58de173e7dffb56eec2aecf3c533559f">unique_by_key</a> </dd>
<dd>
<a class="el" href="group__reductions.html#gac1fadcdd29791f655a3144c2e741838a">reduce_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga59a7948ed24d06d3848d5ae3a087f062"></a><!-- doxytag: member="thrust::unique_copy" ref="ga59a7948ed24d06d3848d5ae3a087f062" args="(InputIterator first, InputIterator last, OutputIterator output, BinaryPredicate binary_pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::unique_copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>unique_copy</code> copies elements from the range <code>[first, last)</code> to a range beginning with <code>output</code>, except that in a consecutive group of duplicate elements only the first one is copied. The return value is the end of the range to which the elements are copied.</p>
<p>This version of <code>unique_copy</code> uses the function object <code>binary_pred</code> to test for equality.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the input range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the input range. </td></tr>
    <tr><td class="paramname">output</td><td>The beginning of the output range. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>The binary predicate used to determine equality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the unique range <code>[output, output_end)</code>.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/EqualityComparable.html">Equality Comparable</a>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a> and and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">BinaryPredicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">Binary Predicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>unique_copy</code> to compact a sequence of numbers to remove consecutive duplicates.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="unique_8h.html" title="Move unique elements to the front of a range.">thrust/unique.h</a>&gt;</span>
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 7;
  <span class="keywordtype">int</span> A[N] = {1, 3, 3, 3, 2, 2, 1};
  <span class="keywordtype">int</span> B[N];
  <span class="keywordtype">int</span> *output_end = <a class="code" href="group__stream__compaction.html#gae039017ffdee9a60fcb23e6c378ef0d6">thrust::unique_copy</a>(A, A + N, B, <a class="code" href="structthrust_1_1equal__to.html">thrust::equal_to&lt;int&gt;</a>());
  <span class="comment">// The first four values of B are now {1, 3, 2, 1} and (output_end - B) is 4</span>
  <span class="comment">// Values beyond output_end are unspecified.</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__stream__compaction.html#ga330c12555aa9d382254c9f1296e3edcc">unique</a> </dd>
<dd>
<a href="http://www.sgi.com/tech/stl/unique_copy.html">http://www.sgi.com/tech/stl/unique_copy.html</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae039017ffdee9a60fcb23e6c378ef0d6"></a><!-- doxytag: member="thrust::unique_copy" ref="gae039017ffdee9a60fcb23e6c378ef0d6" args="(InputIterator first, InputIterator last, OutputIterator output)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::unique_copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>unique_copy</code> copies elements from the range <code>[first, last)</code> to a range beginning with <code>output</code>, except that in a consecutive group of duplicate elements only the first one is copied. The return value is the end of the range to which the elements are copied.</p>
<p>The reason there are two different versions of unique_copy is that there are two different definitions of what it means for a consecutive group of elements to be duplicates. In the first version, the test is simple equality: the elements in a range <code>[f, l)</code> are duplicates if, for every iterator <code>i</code> in the range, either <code>i == f</code> or else <code>*i == *(i-1)</code>. In the second, the test is an arbitrary <code>BinaryPredicate</code> <code>binary_pred:</code> the elements in <code>[f, l)</code> are duplicates if, for every iterator <code>i</code> in the range, either <code>i == f</code> or else <code>binary_pred(*i, *(i-1))</code> is <code>true</code>.</p>
<p>This version of <code>unique_copy</code> uses <code>operator==</code> to test for equality.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the input range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the input range. </td></tr>
    <tr><td class="paramname">output</td><td>The beginning of the output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the unique range <code>[output, output_end)</code>.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/EqualityComparable.html">Equality Comparable</a>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a> and and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>unique_copy</code> to compact a sequence of numbers to remove consecutive duplicates.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="unique_8h.html" title="Move unique elements to the front of a range.">thrust/unique.h</a>&gt;</span>
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 7;
  <span class="keywordtype">int</span> A[N] = {1, 3, 3, 3, 2, 2, 1};
  <span class="keywordtype">int</span> B[N];
  <span class="keywordtype">int</span> * output_end = <a class="code" href="group__stream__compaction.html#gae039017ffdee9a60fcb23e6c378ef0d6">thrust::unique_copy</a>(A, A + N, B);
  <span class="comment">// The first four values of B are now {1, 3, 2, 1} and (output_end - B) is 4</span>
  <span class="comment">// Values beyond output_end are unspecified</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__stream__compaction.html#ga330c12555aa9d382254c9f1296e3edcc">unique</a> </dd>
<dd>
<a href="http://www.sgi.com/tech/stl/unique_copy.html">http://www.sgi.com/tech/stl/unique_copy.html</a> </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon May 7 2012 15:15:01 for thrust by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
