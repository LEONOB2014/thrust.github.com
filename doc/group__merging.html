<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>thrust: Merging</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">thrust
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Merging<div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad0269cdfcd1048406ca429c06f42fef1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gad0269cdfcd1048406ca429c06f42fef1"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__merging.html#gad0269cdfcd1048406ca429c06f42fef1">thrust::merge</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr class="separator:gad0269cdfcd1048406ca429c06f42fef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d2776685a00dca265399f411784acec"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga3d2776685a00dca265399f411784acec"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__merging.html#ga3d2776685a00dca265399f411784acec">thrust::merge</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr class="separator:ga3d2776685a00dca265399f411784acec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25a16faaaf07bb1b7b38d374475845c1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:ga25a16faaaf07bb1b7b38d374475845c1"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__merging.html#ga25a16faaaf07bb1b7b38d374475845c1">thrust::merge</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
<tr class="separator:ga25a16faaaf07bb1b7b38d374475845c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae0c908dc70a47bfd2bfbda46fcc1d12"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:gaae0c908dc70a47bfd2bfbda46fcc1d12"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__merging.html#gaae0c908dc70a47bfd2bfbda46fcc1d12">thrust::merge</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
<tr class="separator:gaae0c908dc70a47bfd2bfbda46fcc1d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabde2e1957b85830a7f18f518ad3491e9"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 &gt; </td></tr>
<tr class="memitem:gabde2e1957b85830a7f18f518ad3491e9"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__merging.html#gabde2e1957b85830a7f18f518ad3491e9">thrust::merge_by_key</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result)</td></tr>
<tr class="separator:gabde2e1957b85830a7f18f518ad3491e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca072577ee54cb35da588205530e026c"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 &gt; </td></tr>
<tr class="memitem:gaca072577ee54cb35da588205530e026c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__merging.html#gaca072577ee54cb35da588205530e026c">thrust::merge_by_key</a> (InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result)</td></tr>
<tr class="separator:gaca072577ee54cb35da588205530e026c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga374392e4928d9cdbc91e966278ddb661"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 , typename Compare &gt; </td></tr>
<tr class="memitem:ga374392e4928d9cdbc91e966278ddb661"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__merging.html#ga374392e4928d9cdbc91e966278ddb661">thrust::merge_by_key</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result, Compare comp)</td></tr>
<tr class="separator:ga374392e4928d9cdbc91e966278ddb661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eb80fefc16967b18f736456e557f411"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 , typename StrictWeakCompare &gt; </td></tr>
<tr class="memitem:ga9eb80fefc16967b18f736456e557f411"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__merging.html#ga9eb80fefc16967b18f736456e557f411">thrust::merge_by_key</a> (InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result, StrictWeakCompare comp)</td></tr>
<tr class="separator:ga9eb80fefc16967b18f736456e557f411"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad0269cdfcd1048406ca429c06f42fef1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ OutputIterator thrust::merge </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>merge</code> combines two sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> into a single sorted range. That is, it copies from <code>[first1, last1)</code> and <code>[first2, last2)</code> into <code>[result, result + (last1 - first1) + (last2 - first2))</code> such that the resulting range is in ascending order. <code>merge</code> is stable, meaning both that the relative order of elements within each input range is preserved, and that for equivalent elements in both input ranges the element from the first range precedes the element from the second. The return value is <code>result + (last1 - first1) + (last2 - first2)</code>.</p>
<p>This version of <code>merge</code> compares elements using <code>operator&lt;</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the merged output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>merge</code> to compute the merger of two sorted sets of integers using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="merge_8h.html">thrust/merge.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[6] = {1, 3, 5, 7, 9, 11};</div>
<div class="line"><span class="keywordtype">int</span> A2[7] = {1, 1, 2, 3, 5,  8, 13};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[13];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end =</div>
<div class="line">  <a class="code" href="group__merging.html#gad0269cdfcd1048406ca429c06f42fef1">thrust::merge</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>,</div>
<div class="line">                A1, A1 + 6,</div>
<div class="line">                A2, A2 + 7,</div>
<div class="line">                result);</div>
<div class="line"><span class="comment">// result = {1, 1, 1, 2, 3, 3, 5, 5, 7, 8, 9, 11, 13}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/merge.html">http://www.sgi.com/tech/stl/merge.html</a> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d2776685a00dca265399f411784acec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::merge </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>merge</code> combines two sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> into a single sorted range. That is, it copies from <code>[first1, last1)</code> and <code>[first2, last2)</code> into <code>[result, result + (last1 - first1) + (last2 - first2))</code> such that the resulting range is in ascending order. <code>merge</code> is stable, meaning both that the relative order of elements within each input range is preserved, and that for equivalent elements in both input ranges the element from the first range precedes the element from the second. The return value is <code>result + (last1 - first1) + (last2 - first2)</code>.</p>
<p>This version of <code>merge</code> compares elements using <code>operator&lt;</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the merged output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>merge</code> to compute the merger of two sorted sets of integers.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="merge_8h.html">thrust/merge.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[6] = {1, 3, 5, 7, 9, 11};</div>
<div class="line"><span class="keywordtype">int</span> A2[7] = {1, 1, 2, 3, 5,  8, 13};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[13];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__merging.html#gad0269cdfcd1048406ca429c06f42fef1">thrust::merge</a>(A1, A1 + 6, A2, A2 + 7, result);</div>
<div class="line"><span class="comment">// result = {1, 1, 1, 2, 3, 3, 5, 5, 7, 8, 9, 11, 13}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/merge.html">http://www.sgi.com/tech/stl/merge.html</a> </dd>
<dd>
<code><a class="el" href="group__set__operations.html#ga974aed5fabc60590b7efa20464021caf">set_union</a></code> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga25a16faaaf07bb1b7b38d374475845c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ OutputIterator thrust::merge </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>merge</code> combines two sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> into a single sorted range. That is, it copies from <code>[first1, last1)</code> and <code>[first2, last2)</code> into <code>[result, result + (last1 - first1) + (last2 - first2))</code> such that the resulting range is in ascending order. <code>merge</code> is stable, meaning both that the relative order of elements within each input range is preserved, and that for equivalent elements in both input ranges the element from the first range precedes the element from the second. The return value is <code>result + (last1 - first1) + (last2 - first2)</code>.</p>
<p>This version of <code>merge</code> compares elements using a function object <code>comp</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the merged output. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>first_argument_type</code>. and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>second_argument_type</code>. and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">StrictWeakCompare</td><td>is a model of <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict Weak Ordering</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>merge</code> to compute the merger of two sets of integers sorted in descending order using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="merge_8h.html">thrust/merge.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[6] = {11, 9, 7, 5, 3, 1};</div>
<div class="line"><span class="keywordtype">int</span> A2[7] = {13, 8, 5, 3, 2, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[13];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__merging.html#gad0269cdfcd1048406ca429c06f42fef1">thrust::merge</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>,</div>
<div class="line">                                A1, A1 + 6,</div>
<div class="line">                                A2, A2 + 7,</div>
<div class="line">                                result,</div>
<div class="line">                                thrust::greater&lt;int&gt;());</div>
<div class="line"><span class="comment">// result = {13, 11, 9, 8, 7, 5, 5, 3, 3, 2, 1, 1, 1}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/merge.html">http://www.sgi.com/tech/stl/merge.html</a> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="gaae0c908dc70a47bfd2bfbda46fcc1d12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::merge </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>merge</code> combines two sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> into a single sorted range. That is, it copies from <code>[first1, last1)</code> and <code>[first2, last2)</code> into <code>[result, result + (last1 - first1) + (last2 - first2))</code> such that the resulting range is in ascending order. <code>merge</code> is stable, meaning both that the relative order of elements within each input range is preserved, and that for equivalent elements in both input ranges the element from the first range precedes the element from the second. The return value is <code>result + (last1 - first1) + (last2 - first2)</code>.</p>
<p>This version of <code>merge</code> compares elements using a function object <code>comp</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the first input range. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the first input range. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the second input range. </td></tr>
    <tr><td class="paramname">last2</td><td>The end of the second input range. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the merged output. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>first_argument_type</code>. and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>second_argument_type</code>. and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">StrictWeakCompare</td><td>is a model of <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict Weak Ordering</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting range shall not overlap with either input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>merge</code> to compute the merger of two sets of integers sorted in descending order.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="merge_8h.html">thrust/merge.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A1[6] = {11, 9, 7, 5, 3, 1};</div>
<div class="line"><span class="keywordtype">int</span> A2[7] = {13, 8, 5, 3, 2, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> result[13];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *result_end = <a class="code" href="group__merging.html#gad0269cdfcd1048406ca429c06f42fef1">thrust::merge</a>(A1, A1 + 6, A2, A2 + 7, result, thrust::greater&lt;int&gt;());</div>
<div class="line"><span class="comment">// result = {13, 11, 9, 8, 7, 5, 5, 3, 3, 2, 1, 1, 1}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/merge.html">http://www.sgi.com/tech/stl/merge.html</a> </dd>
<dd>
<code><a class="el" href="group__sorting.html#ga1099d781e06c43805be06a918f7b7499">sort</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="gabde2e1957b85830a7f18f518ad3491e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::merge_by_key </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>values_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>merge_by_key</code> performs a key-value merge. That is, <code>merge_by_key</code> copies elements from <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> into a single range, <code>[keys_result, keys_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))</code> such that the resulting range is in ascending key order.</p>
<p>At the same time, <code>merge_by_key</code> copies elements from the two associated ranges <code>[values_first1 + (keys_last1 - keys_first1))</code> and <code>[values_first2 + (keys_last2 - keys_first2))</code> into a single range, <code>[values_result, values_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))</code> such that the resulting range is in ascending order implied by each input element's associated key.</p>
<p><code>merge_by_key</code> is stable, meaning both that the relative order of elements within each input range is preserved, and that for equivalent elements in all input key ranges the element from the first range precedes the element from the second.</p>
<p>The return value is is <code>(keys_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))</code> and <code>(values_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))</code>.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">values_first2</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the merged output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the merged output range of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator4</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator4's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>merge_by_key</code> to compute the merger of two sets of integers sorted in ascending order using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="merge_8h.html">thrust/merge.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {1, 3, 5, 7, 9, 11};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = {0, 0, 0, 0, 0, 0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[7] = {1, 1, 2, 3, 5, 8, 13};</div>
<div class="line"><span class="keywordtype">int</span> B_vals[7] = {1, 1, 1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[13];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[13];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end =</div>
<div class="line">  <a class="code" href="group__merging.html#gabde2e1957b85830a7f18f518ad3491e9">thrust::merge_by_key</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>,</div>
<div class="line">                       A_keys, A_keys + 6,</div>
<div class="line">                       B_keys, B_keys + 7,</div>
<div class="line">                       A_vals, B_vals,</div>
<div class="line">                       keys_result, vals_result);</div>
<div class="line"></div>
<div class="line"><span class="comment">// keys_result = {1, 1, 1, 2, 3, 3, 5, 5, 7, 8, 9, 11, 13}</span></div>
<div class="line"><span class="comment">// vals_result = {0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0,  0,  1}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__merging.html#gad0269cdfcd1048406ca429c06f42fef1">merge</a> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="gaca072577ee54cb35da588205530e026c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::merge_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>values_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>merge_by_key</code> performs a key-value merge. That is, <code>merge_by_key</code> copies elements from <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> into a single range, <code>[keys_result, keys_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))</code> such that the resulting range is in ascending key order.</p>
<p>At the same time, <code>merge_by_key</code> copies elements from the two associated ranges <code>[values_first1 + (keys_last1 - keys_first1))</code> and <code>[values_first2 + (keys_last2 - keys_first2))</code> into a single range, <code>[values_result, values_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))</code> such that the resulting range is in ascending order implied by each input element's associated key.</p>
<p><code>merge_by_key</code> is stable, meaning both that the relative order of elements within each input range is preserved, and that for equivalent elements in all input key ranges the element from the first range precedes the element from the second.</p>
<p>The return value is is <code>(keys_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))</code> and <code>(values_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">values_first2</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the merged output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the merged output range of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value_type</code>, <code>InputIterator1's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value_type</code>, <code>InputIterator2's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code> <code>value_type</code> is a strict weak ordering, as defined in the <a href="http://www.sgi.com/tech/stl/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator4</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator4's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>operator&lt;</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>merge_by_key</code> to compute the merger of two sets of integers sorted in ascending order.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="merge_8h.html">thrust/merge.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {1, 3, 5, 7, 9, 11};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = {0, 0, 0, 0, 0, 0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[7] = {1, 1, 2, 3, 5, 8, 13};</div>
<div class="line"><span class="keywordtype">int</span> B_vals[7] = {1, 1, 1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[13];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[13];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end = <a class="code" href="group__merging.html#gabde2e1957b85830a7f18f518ad3491e9">thrust::merge_by_key</a>(A_keys, A_keys + 6, B_keys, B_keys + 7, A_vals, B_vals, keys_result, vals_result);</div>
<div class="line"></div>
<div class="line"><span class="comment">// keys_result = {1, 1, 1, 2, 3, 3, 5, 5, 7, 8, 9, 11, 13}</span></div>
<div class="line"><span class="comment">// vals_result = {0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0,  0,  1}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__merging.html#gad0269cdfcd1048406ca429c06f42fef1">merge</a> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga374392e4928d9cdbc91e966278ddb661"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::merge_by_key </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>values_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>merge_by_key</code> performs a key-value merge. That is, <code>merge_by_key</code> copies elements from <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> into a single range, <code>[keys_result, keys_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))</code> such that the resulting range is in ascending key order.</p>
<p>At the same time, <code>merge_by_key</code> copies elements from the two associated ranges <code>[values_first1 + (keys_last1 - keys_first1))</code> and <code>[values_first2 + (keys_last2 - keys_first2))</code> into a single range, <code>[values_result, values_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))</code> such that the resulting range is in ascending order implied by each input element's associated key.</p>
<p><code>merge_by_key</code> is stable, meaning both that the relative order of elements within each input range is preserved, and that for equivalent elements in all input key ranges the element from the first range precedes the element from the second.</p>
<p>The return value is is <code>(keys_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))</code> and <code>(values_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))</code>.</p>
<p>This version of <code>merge_by_key</code> compares key elements using a function object <code>comp</code>.</p>
<p>The algorithm's execution is parallelized using <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">values_first2</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the merged output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the merged output range of values. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>first_argument_type</code>. and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator1's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>second_argument_type</code>. and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator1's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator4</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator4's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">StrictWeakCompare</td><td>is a model of <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict Weak Ordering</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>merge_by_key</code> to compute the merger of two sets of integers sorted in descending order using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="merge_8h.html">thrust/merge.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {11, 9, 7, 5, 3, 1};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = { 0, 0, 0, 0, 0, 0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[7] = {13, 8, 5, 3, 2, 1, 1};</div>
<div class="line"><span class="keywordtype">int</span> B_vals[7] = { 1, 1, 1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[13];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[13];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end =</div>
<div class="line">  <a class="code" href="group__merging.html#gabde2e1957b85830a7f18f518ad3491e9">thrust::merge_by_key</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>,</div>
<div class="line">                       A_keys, A_keys + 6,</div>
<div class="line">                       B_keys, B_keys + 7,</div>
<div class="line">                       A_vals, B_vals,</div>
<div class="line">                       keys_result, vals_result,</div>
<div class="line">                       thrust::greater&lt;int&gt;());</div>
<div class="line"></div>
<div class="line"><span class="comment">// keys_result = {13, 11, 9, 8, 7, 5, 5, 3, 3, 2, 1, 1, 1}</span></div>
<div class="line"><span class="comment">// vals_result = { 1,  0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__merging.html#gad0269cdfcd1048406ca429c06f42fef1">merge</a> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9eb80fefc16967b18f736456e557f411"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename InputIterator4 , typename OutputIterator1 , typename OutputIterator2 , typename StrictWeakCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt;OutputIterator1,OutputIterator2&gt; thrust::merge_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>keys_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keys_last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>values_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>values_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>keys_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>values_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>merge_by_key</code> performs a key-value merge. That is, <code>merge_by_key</code> copies elements from <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> into a single range, <code>[keys_result, keys_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))</code> such that the resulting range is in ascending key order.</p>
<p>At the same time, <code>merge_by_key</code> copies elements from the two associated ranges <code>[values_first1 + (keys_last1 - keys_first1))</code> and <code>[values_first2 + (keys_last2 - keys_first2))</code> into a single range, <code>[values_result, values_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))</code> such that the resulting range is in ascending order implied by each input element's associated key.</p>
<p><code>merge_by_key</code> is stable, meaning both that the relative order of elements within each input range is preserved, and that for equivalent elements in all input key ranges the element from the first range precedes the element from the second.</p>
<p>The return value is is <code>(keys_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))</code> and <code>(values_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))</code>.</p>
<p>This version of <code>merge_by_key</code> compares key elements using a function object <code>comp</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys_first1</td><td>The beginning of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_last1</td><td>The end of the first input range of keys. </td></tr>
    <tr><td class="paramname">keys_first2</td><td>The beginning of the second input range of keys. </td></tr>
    <tr><td class="paramname">keys_last2</td><td>The end of the second input range of keys. </td></tr>
    <tr><td class="paramname">values_first1</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">values_first2</td><td>The beginning of the first input range of values. </td></tr>
    <tr><td class="paramname">keys_result</td><td>The beginning of the merged output range of keys. </td></tr>
    <tr><td class="paramname">values_result</td><td>The beginning of the merged output range of values. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> <code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator1's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>first_argument_type</code>. and <code>InputIterator1's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator1's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator2's</code> <code>value_type</code> is convertable to <code>StrictWeakCompare's</code> <code>second_argument_type</code>. and <code>InputIterator2's</code> <code>value_type</code> is convertable to a type in <code>OutputIterator1's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator3</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator3's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">InputIterator4</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator4's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value_types</code>. </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td class="paramname">StrictWeakCompare</td><td>is a model of <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict Weak Ordering</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ranges <code>[keys_first1, keys_last1)</code> and <code>[keys_first2, keys_last2)</code> shall be sorted with respect to <code>comp</code>. </dd>
<dd>
The resulting ranges shall not overlap with any input range.</dd></dl>
<p>The following code snippet demonstrates how to use <code>merge_by_key</code> to compute the merger of two sets of integers sorted in descending order.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="merge_8h.html">thrust/merge.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">int A_keys[6] = {11, 9, 7, 5, 3, 1};</div>
<div class="line"><span class="keywordtype">int</span> A_vals[6] = { 0, 0, 0, 0, 0, 0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> B_keys[7] = {13, 8, 5, 3, 2, 1, 1};</div>
<div class="line"><span class="keywordtype">int</span> B_vals[7] = { 1, 1, 1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys_result[13];</div>
<div class="line"><span class="keywordtype">int</span> vals_result[13];</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1pair.html">thrust::pair&lt;int*,int*&gt;</a> end = <a class="code" href="group__merging.html#gabde2e1957b85830a7f18f518ad3491e9">thrust::merge_by_key</a>(A_keys, A_keys + 6, B_keys, B_keys + 7, A_vals, B_vals, keys_result, vals_result, thrust::greater&lt;int&gt;());</div>
<div class="line"></div>
<div class="line"><span class="comment">// keys_result = {13, 11, 9, 8, 7, 5, 5, 3, 3, 2, 1, 1, 1}</span></div>
<div class="line"><span class="comment">// vals_result = { 1,  0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__merging.html#gad0269cdfcd1048406ca429c06f42fef1">merge</a> </dd>
<dd>
<code><a class="el" href="group__sorting.html#gabe038d6107f7c824cf74120500ef45ea">sort_by_key</a></code> </dd>
<dd>
<code><a class="el" href="group__predicates.html#ga1cf02f6a212f4f2e4998f517626e5e7c">is_sorted</a></code> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 12 2015 13:59:07 for thrust by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
