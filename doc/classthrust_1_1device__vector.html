<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>thrust: thrust::device_vector&lt; T, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">thrust
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacethrust.html">thrust</a></li><li class="navelem"><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classthrust_1_1device__vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">thrust::device_vector&lt; T, Alloc &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__device__containers.html">Device Containers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="device__vector_8h_source.html">device_vector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:affe7992a8996db6297d541f774ef57e3"><td class="memItemLeft" align="right" valign="top">__host__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#affe7992a8996db6297d541f774ef57e3">device_vector</a> (void)</td></tr>
<tr class="memitem:a48f7a2a36e030fca52d533f18e684ad0"><td class="memItemLeft" align="right" valign="top">__host__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a48f7a2a36e030fca52d533f18e684ad0">device_vector</a> (size_type n)</td></tr>
<tr class="memitem:a53fd7a2e35ddd1125985a5af96d58513"><td class="memItemLeft" align="right" valign="top">__host__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a53fd7a2e35ddd1125985a5af96d58513">device_vector</a> (size_type n, const value_type &amp;value)</td></tr>
<tr class="memitem:a664d90af3a31119caec707c05671fc3e"><td class="memItemLeft" align="right" valign="top">__host__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a664d90af3a31119caec707c05671fc3e">device_vector</a> (const <a class="el" href="classthrust_1_1device__vector.html">device_vector</a> &amp;v)</td></tr>
<tr class="memitem:a6925a9dc896b383edb35a6c340e1feb3"><td class="memTemplParams" colspan="2">template&lt;typename OtherT , typename OtherAlloc &gt; </td></tr>
<tr class="memitem:a6925a9dc896b383edb35a6c340e1feb3"><td class="memTemplItemLeft" align="right" valign="top">__device__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a6925a9dc896b383edb35a6c340e1feb3">device_vector</a> (const <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&lt; OtherT, OtherAlloc &gt; &amp;v)</td></tr>
<tr class="memitem:ab5c36814a4e22bfe00a924866d4b9e0e"><td class="memTemplParams" colspan="2">template&lt;typename OtherT , typename OtherAlloc &gt; </td></tr>
<tr class="memitem:ab5c36814a4e22bfe00a924866d4b9e0e"><td class="memTemplItemLeft" align="right" valign="top">__device__ <a class="el" href="classthrust_1_1device__vector.html">device_vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#ab5c36814a4e22bfe00a924866d4b9e0e">operator=</a> (const <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&lt; OtherT, OtherAlloc &gt; &amp;v)</td></tr>
<tr class="memitem:a40ef9f4fa879fe55fdd4d931e6dc79b8"><td class="memTemplParams" colspan="2">template&lt;typename OtherT , typename OtherAlloc &gt; </td></tr>
<tr class="memitem:a40ef9f4fa879fe55fdd4d931e6dc79b8"><td class="memTemplItemLeft" align="right" valign="top">__host__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a40ef9f4fa879fe55fdd4d931e6dc79b8">device_vector</a> (const std::vector&lt; OtherT, OtherAlloc &gt; &amp;v)</td></tr>
<tr class="memitem:ae2c21c4f22cb44d2e41e2a4c9d3409c9"><td class="memTemplParams" colspan="2">template&lt;typename OtherT , typename OtherAlloc &gt; </td></tr>
<tr class="memitem:ae2c21c4f22cb44d2e41e2a4c9d3409c9"><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="classthrust_1_1device__vector.html">device_vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#ae2c21c4f22cb44d2e41e2a4c9d3409c9">operator=</a> (const std::vector&lt; OtherT, OtherAlloc &gt; &amp;v)</td></tr>
<tr class="memitem:ab47a876188b151e9b6fbe7a66aec9b6f"><td class="memTemplParams" colspan="2">template&lt;typename OtherT , typename OtherAlloc &gt; </td></tr>
<tr class="memitem:ab47a876188b151e9b6fbe7a66aec9b6f"><td class="memTemplItemLeft" align="right" valign="top">__host__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#ab47a876188b151e9b6fbe7a66aec9b6f">device_vector</a> (const <a class="el" href="classthrust_1_1host__vector.html">host_vector</a>&lt; OtherT, OtherAlloc &gt; &amp;v)</td></tr>
<tr class="memitem:ab061658889659eb24f71cfefe24638d2"><td class="memTemplParams" colspan="2">template&lt;typename OtherT , typename OtherAlloc &gt; </td></tr>
<tr class="memitem:ab061658889659eb24f71cfefe24638d2"><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="classthrust_1_1device__vector.html">device_vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#ab061658889659eb24f71cfefe24638d2">operator=</a> (const <a class="el" href="classthrust_1_1host__vector.html">host_vector</a>&lt; OtherT, OtherAlloc &gt; &amp;v)</td></tr>
<tr class="memitem:a1294d3eda46609a4b3311973bb6c3167"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a1294d3eda46609a4b3311973bb6c3167"><td class="memTemplItemLeft" align="right" valign="top">__host__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a1294d3eda46609a4b3311973bb6c3167">device_vector</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memitem:acc3779e3af47e1392ac2ca6f9377e2a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#acc3779e3af47e1392ac2ca6f9377e2a5">resize</a> (size_type new_size, const value_type &amp;x=value_type())</td></tr>
<tr class="memdesc:acc3779e3af47e1392ac2ca6f9377e2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this vector to the specified number of elements.  <a href="#acc3779e3af47e1392ac2ca6f9377e2a5"></a><br/></td></tr>
<tr class="memitem:a72802742bce8422af09861ea24bc9bf7"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size</a> (void) const </td></tr>
<tr class="memitem:a513a99c29746f120789476eb4e5970ac"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a513a99c29746f120789476eb4e5970ac">max_size</a> (void) const </td></tr>
<tr class="memitem:a94fb215e30e377ff576495b71c833e2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a94fb215e30e377ff576495b71c833e2f">reserve</a> (size_type n)</td></tr>
<tr class="memdesc:a94fb215e30e377ff576495b71c833e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If n is less than or equal to <a class="el" href="classthrust_1_1device__vector.html#af958db3d0ff4b1d05564f9da1e0d0354">capacity()</a>, this call has no effect. Otherwise, this method is a request for allocation of additional memory. If the request is successful, then <a class="el" href="classthrust_1_1device__vector.html#af958db3d0ff4b1d05564f9da1e0d0354">capacity()</a> is greater than or equal to n; otherwise, <a class="el" href="classthrust_1_1device__vector.html#af958db3d0ff4b1d05564f9da1e0d0354">capacity()</a> is unchanged. In either case, <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a> is unchanged.  <a href="#a94fb215e30e377ff576495b71c833e2f"></a><br/></td></tr>
<tr class="memitem:af958db3d0ff4b1d05564f9da1e0d0354"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#af958db3d0ff4b1d05564f9da1e0d0354">capacity</a> (void) const </td></tr>
<tr class="memitem:a22f3b4f508cdfc3e5e843fdff3fc0ee6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a22f3b4f508cdfc3e5e843fdff3fc0ee6">shrink_to_fit</a> (void)</td></tr>
<tr class="memitem:a58941f0d61aabbd377f39766d8ab4d68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrust_1_1reference.html">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a58941f0d61aabbd377f39766d8ab4d68">operator[]</a> (size_type n)</td></tr>
<tr class="memdesc:a58941f0d61aabbd377f39766d8ab4d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript access to the data contained in this vector_dev.  <a href="#a58941f0d61aabbd377f39766d8ab4d68"></a><br/></td></tr>
<tr class="memitem:a62ef321ccafbcda290b59aafa3c4d05d"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a62ef321ccafbcda290b59aafa3c4d05d">operator[]</a> (size_type n) const </td></tr>
<tr class="memdesc:a62ef321ccafbcda290b59aafa3c4d05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript read access to the data contained in this vector_dev.  <a href="#a62ef321ccafbcda290b59aafa3c4d05d"></a><br/></td></tr>
<tr class="memitem:a107c4d374ddd0ba4bf96ed5ad875b1de"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a107c4d374ddd0ba4bf96ed5ad875b1de">begin</a> (void)</td></tr>
<tr class="memitem:a8c968e1de414938ab49d3d88d25ce5a3"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a8c968e1de414938ab49d3d88d25ce5a3">begin</a> (void) const </td></tr>
<tr class="memitem:a9ed1fef988525b47367452b1a5131a2f"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a9ed1fef988525b47367452b1a5131a2f">cbegin</a> (void) const </td></tr>
<tr class="memitem:ab8d7268facdd1dc28ee71520b3cbc9e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrust_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#ab8d7268facdd1dc28ee71520b3cbc9e2">rbegin</a> (void)</td></tr>
<tr class="memitem:a2dd2d733b78ea24c21e5abd24ac1ec6b"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a2dd2d733b78ea24c21e5abd24ac1ec6b">rbegin</a> (void) const </td></tr>
<tr class="memitem:abbe8926d0a8bd2e93baec81cd3efdcc1"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#abbe8926d0a8bd2e93baec81cd3efdcc1">crbegin</a> (void) const </td></tr>
<tr class="memitem:ac534e03ce92587b0e56d7defe1db4a72"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#ac534e03ce92587b0e56d7defe1db4a72">end</a> (void)</td></tr>
<tr class="memitem:a83a0c72634dfa62ebb727c614e946ca8"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a83a0c72634dfa62ebb727c614e946ca8">end</a> (void) const </td></tr>
<tr class="memitem:a20429935a14c2f8cfc8eb668df1da605"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a20429935a14c2f8cfc8eb668df1da605">cend</a> (void) const </td></tr>
<tr class="memitem:a451f3922982e197755978e6530990881"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrust_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a451f3922982e197755978e6530990881">rend</a> (void)</td></tr>
<tr class="memitem:a03a48b30549e1934ab7d924d04d7aae7"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a03a48b30549e1934ab7d924d04d7aae7">rend</a> (void) const </td></tr>
<tr class="memitem:af2e854a2722ad5ecf8278832de9ff1b0"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#af2e854a2722ad5ecf8278832de9ff1b0">crend</a> (void) const </td></tr>
<tr class="memitem:ae0fd61c32fc27934be03d458ab0a5203"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#ae0fd61c32fc27934be03d458ab0a5203">front</a> (void) const </td></tr>
<tr class="memitem:a2d7e5a51e0843309c8404ff88efca2e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrust_1_1reference.html">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a2d7e5a51e0843309c8404ff88efca2e1">front</a> (void)</td></tr>
<tr class="memitem:a547072f4e0cb5249541d0ebe60d2f6e0"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a547072f4e0cb5249541d0ebe60d2f6e0">back</a> (void) const </td></tr>
<tr class="memitem:a4666c9f72654e25ae00460ab0597e45a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrust_1_1reference.html">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a4666c9f72654e25ae00460ab0597e45a">back</a> (void)</td></tr>
<tr class="memitem:a0a59b533bd276a8836e5d5f4ea4c2641"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrust_1_1pointer.html">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a0a59b533bd276a8836e5d5f4ea4c2641">data</a> (void)</td></tr>
<tr class="memitem:adda247ed99d80bbd11e59aa64e2a7c82"><td class="memItemLeft" align="right" valign="top">const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#adda247ed99d80bbd11e59aa64e2a7c82">data</a> (void) const </td></tr>
<tr class="memitem:a242de09fb73c8c18008c2de1b51e9bc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a242de09fb73c8c18008c2de1b51e9bc5">clear</a> (void)</td></tr>
<tr class="memitem:af75977aae033970c26604cae6ce29a82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#af75977aae033970c26604cae6ce29a82">empty</a> (void) const </td></tr>
<tr class="memitem:a768fd54edd31e07d4a2078b0bb972fea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a768fd54edd31e07d4a2078b0bb972fea">push_back</a> (const value_type &amp;x)</td></tr>
<tr class="memitem:a12bc87105a149e4a7d94d728229c254b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a12bc87105a149e4a7d94d728229c254b">pop_back</a> (void)</td></tr>
<tr class="memitem:afbb2ba9fb2d40c551598d12d770d68b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#afbb2ba9fb2d40c551598d12d770d68b6">swap</a> (<a class="el" href="classthrust_1_1device__vector.html">device_vector</a> &amp;v)</td></tr>
<tr class="memitem:a0bd666527f0130e1a265739ee2c77d13"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a0bd666527f0130e1a265739ee2c77d13">erase</a> (iterator pos)</td></tr>
<tr class="memitem:ae799093cda17da5619eeb2baf7f2826a"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#ae799093cda17da5619eeb2baf7f2826a">erase</a> (iterator first, iterator last)</td></tr>
<tr class="memitem:ac8e714f6c50e339d66c1a87bf9c3b161"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#ac8e714f6c50e339d66c1a87bf9c3b161">insert</a> (iterator position, const T &amp;x)</td></tr>
<tr class="memitem:aa74f622e3e5e2b71b28b165cfcfd304e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#aa74f622e3e5e2b71b28b165cfcfd304e">insert</a> (iterator position, size_type n, const T &amp;x)</td></tr>
<tr class="memitem:ac9c97439c55176904543b905de3c9bae"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ac9c97439c55176904543b905de3c9bae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#ac9c97439c55176904543b905de3c9bae">insert</a> (iterator position, InputIterator first, InputIterator last)</td></tr>
<tr class="memitem:a4a0728a800ca1da9bcc6c8bfef019372"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a4a0728a800ca1da9bcc6c8bfef019372">assign</a> (size_type n, const T &amp;x)</td></tr>
<tr class="memitem:aeef38fef5d50d7346b1351b7113ab345"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:aeef38fef5d50d7346b1351b7113ab345"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#aeef38fef5d50d7346b1351b7113ab345">assign</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memitem:a3103d80c3f45d75540bba2d9cda20ac3"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a3103d80c3f45d75540bba2d9cda20ac3">get_allocator</a> (void) const </td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt;<br/>
class thrust::device_vector&lt; T, Alloc &gt;</h3>

<p>A <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> is a container that supports random access to elements, constant time removal of elements at the end, and linear time insertion and removal of elements at the beginning or in the middle. The number of elements in a <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> may vary dynamically; memory management is automatic. The memory associated with a <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> resides in the memory space of a parallel device.</p>
<dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/Vector.html">http://www.sgi.com/tech/stl/Vector.html</a> </dd>
<dd>
<a class="el" href="classthrust_1_1host__vector.html">host_vector</a> </dd></dl>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="affe7992a8996db6297d541f774ef57e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::<a class="el" href="classthrust_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This constructor creates an empty <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code>. </p>

</div>
</div>
<a class="anchor" id="a48f7a2a36e030fca52d533f18e684ad0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::<a class="el" href="classthrust_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This constructor creates a <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> with the given size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of elements to initially craete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53fd7a2e35ddd1125985a5af96d58513"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::<a class="el" href="classthrust_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This constructor creates a <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> with copies of an exemplar element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of elements to initially create. </td></tr>
    <tr><td class="paramname">value</td><td>An element to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a664d90af3a31119caec707c05671fc3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::<a class="el" href="classthrust_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor copies from an exemplar <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6925a9dc896b383edb35a6c340e1feb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OtherT , typename OtherAlloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::<a class="el" href="classthrust_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&lt; OtherT, OtherAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor copies from an exemplar <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> with different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40ef9f4fa879fe55fdd4d931e6dc79b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OtherT , typename OtherAlloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::<a class="el" href="classthrust_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; OtherT, OtherAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor copies from an exemplar <code>std::vector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <code>std::vector</code> to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab47a876188b151e9b6fbe7a66aec9b6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OtherT , typename OtherAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::<a class="el" href="classthrust_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrust_1_1host__vector.html">host_vector</a>&lt; OtherT, OtherAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor copies from an exemplar <code><a class="el" href="classthrust_1_1host__vector.html">host_vector</a></code> with possibly different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <code><a class="el" href="classthrust_1_1host__vector.html">host_vector</a></code> to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1294d3eda46609a4b3311973bb6c3167"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::<a class="el" href="classthrust_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This constructor builds a <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> from a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a4a0728a800ca1da9bcc6c8bfef019372"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This version of <code>assign</code> replicates a given exemplar <code>n</code> times into this vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of times to copy <code>x</code>. </td></tr>
    <tr><td class="paramname">x</td><td>The exemplar element to replicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeef38fef5d50d7346b1351b7113ab345"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This version of <code>assign</code> makes this vector a copy of a given input range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range to copy. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator">Input Iterator</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a547072f4e0cb5249541d0ebe60d2f6e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a const reference pointing to the last element of this vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The last element of this vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a4666c9f72654e25ae00460ab0597e45a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrust_1_1reference.html">reference</a> <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a reference referring to the last element of this vector_dev. </p>
<dl class="section return"><dt>Returns</dt><dd>The last element of this vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a107c4d374ddd0ba4bf96ed5ad875b1de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns an iterator pointing to the beginning of this vector. </p>
<dl class="section return"><dt>Returns</dt><dd>mStart </dd></dl>

</div>
</div>
<a class="anchor" id="a8c968e1de414938ab49d3d88d25ce5a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a const_iterator pointing to the beginning of this vector. </p>
<dl class="section return"><dt>Returns</dt><dd>mStart </dd></dl>

</div>
</div>
<a class="anchor" id="af958db3d0ff4b1d05564f9da1e0d0354"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of elements which have been reserved in this vector. </p>

</div>
</div>
<a class="anchor" id="a9ed1fef988525b47367452b1a5131a2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a const_iterator pointing to the beginning of this vector. </p>
<dl class="section return"><dt>Returns</dt><dd>mStart </dd></dl>

</div>
</div>
<a class="anchor" id="a20429935a14c2f8cfc8eb668df1da605"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a const_iterator pointing to one element past the last of this vector. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classthrust_1_1device__vector.html#a107c4d374ddd0ba4bf96ed5ad875b1de">begin()</a> + <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a242de09fb73c8c18008c2de1b51e9bc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method resizes this vector to 0. </p>

</div>
</div>
<a class="anchor" id="abbe8926d0a8bd2e93baec81cd3efdcc1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::crbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a const_reverse_iterator pointing to the beginning of this vector's reversed sequence. </p>
<dl class="section return"><dt>Returns</dt><dd>A const_reverse_iterator pointing to the beginning of this vector's reversed sequence. </dd></dl>

</div>
</div>
<a class="anchor" id="af2e854a2722ad5ecf8278832de9ff1b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::crend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a const_reverse_iterator pointing to one element past the last of this vector's reversed sequence. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classthrust_1_1device__vector.html#ab8d7268facdd1dc28ee71520b3cbc9e2">rbegin()</a> + <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a59b533bd276a8836e5d5f4ea4c2641"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrust_1_1pointer.html">pointer</a> <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a pointer to this vector's first element. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element of this vector. </dd></dl>

</div>
</div>
<a class="anchor" id="adda247ed99d80bbd11e59aa64e2a7c82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_pointer <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a const_pointer to this vector's first element. </p>
<dl class="section return"><dt>Returns</dt><dd>a const_pointer to the first element of this vector. </dd></dl>

</div>
</div>
<a class="anchor" id="af75977aae033970c26604cae6ce29a82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns true iff <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a> == 0. </p>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a> == 0; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac534e03ce92587b0e56d7defe1db4a72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns an iterator pointing to one element past the last of this vector. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classthrust_1_1device__vector.html#a107c4d374ddd0ba4bf96ed5ad875b1de">begin()</a> + <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a83a0c72634dfa62ebb727c614e946ca8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a const_iterator pointing to one element past the last of this vector. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classthrust_1_1device__vector.html#a107c4d374ddd0ba4bf96ed5ad875b1de">begin()</a> + <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bd666527f0130e1a265739ee2c77d13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method removes the element at position pos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the element of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the new location of the element that followed the element at position pos. </dd></dl>

</div>
</div>
<a class="anchor" id="ae799093cda17da5619eeb2baf7f2826a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method removes the range of elements [first,last) from this vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range of elements to remove. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range of elements to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the new location of the element that followed the last element in the sequence [first,last). </dd></dl>

</div>
</div>
<a class="anchor" id="ae0fd61c32fc27934be03d458ab0a5203"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a const_reference referring to the first element of this vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The first element of this vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d7e5a51e0843309c8404ff88efca2e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrust_1_1reference.html">reference</a> <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a reference pointing to the first element of this vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The first element of this vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a3103d80c3f45d75540bba2d9cda20ac3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a copy of this vector's allocator. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the alloctor used by this vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8e714f6c50e339d66c1a87bf9c3b161"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method inserts a single copy of a given exemplar value at the specified position in this vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The insertion position. </td></tr>
    <tr><td class="paramname">x</td><td>The exemplar element to copy &amp; insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the newly inserted element. </dd></dl>

</div>
</div>
<a class="anchor" id="aa74f622e3e5e2b71b28b165cfcfd304e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method inserts a copy of an exemplar value to a range at the specified position in this vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The insertion position </td></tr>
    <tr><td class="paramname">n</td><td>The number of insertions to perform. </td></tr>
    <tr><td class="paramname">x</td><td>The value to replicate and insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9c97439c55176904543b905de3c9bae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method inserts a copy of an input range at the specified position in this vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The insertion position. </td></tr>
    <tr><td class="paramname">first</td><td>The beginning of the range to copy. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>is a model of &lt;a href="http://www.sgi.com/tech/stl/InputIterator.html&gt;Input Iterator&lt;/a&gt;,
                             and \p InputIterator's \c value_type is a model of &lt;a href="<a href="http://www.sgi.com/tech/stl/Assignable.html">http://www.sgi.com/tech/stl/Assignable.html</a>"&gt;Assignable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a513a99c29746f120789476eb4e5970ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a> of the largest possible vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The largest possible return value of <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5c36814a4e22bfe00a924866d4b9e0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OtherT , typename OtherAlloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&amp; <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&lt; OtherT, OtherAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign operator copies from an exemplar <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> with different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> to copy. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classthrust_1_1device__vector.html#ae2c21c4f22cb44d2e41e2a4c9d3409c9">thrust::device_vector&lt; T, Alloc &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2c21c4f22cb44d2e41e2a4c9d3409c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OtherT , typename OtherAlloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&amp; <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; OtherT, OtherAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign operator copies from an exemplar <code>std::vector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <code>std::vector</code> to copy. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classthrust_1_1device__vector.html#ab5c36814a4e22bfe00a924866d4b9e0e">thrust::device_vector&lt; T, Alloc &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="ab061658889659eb24f71cfefe24638d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OtherT , typename OtherAlloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&amp; <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrust_1_1host__vector.html">host_vector</a>&lt; OtherT, OtherAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign operator copies from an examplar <code><a class="el" href="classthrust_1_1host__vector.html">host_vector</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <code><a class="el" href="classthrust_1_1host__vector.html">host_vector</a></code> to copy. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classthrust_1_1device__vector.html#ab5c36814a4e22bfe00a924866d4b9e0e">thrust::device_vector&lt; T, Alloc &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a58941f0d61aabbd377f39766d8ab4d68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrust_1_1reference.html">reference</a> <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscript access to the data contained in this vector_dev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read/write reference to data.</dd></dl>
<p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. </p>

</div>
</div>
<a class="anchor" id="a62ef321ccafbcda290b59aafa3c4d05d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscript read access to the data contained in this vector_dev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read reference to data.</dd></dl>
<p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. </p>

</div>
</div>
<a class="anchor" id="a12bc87105a149e4a7d94d728229c254b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::pop_back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method erases the last element of this vector, invalidating all iterators and references to it. </p>

</div>
</div>
<a class="anchor" id="a768fd54edd31e07d4a2078b0bb972fea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method appends the given element to the end of this vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The element to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8d7268facdd1dc28ee71520b3cbc9e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrust_1_1reverse__iterator.html">reverse_iterator</a> <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a <a class="el" href="classthrust_1_1reverse__iterator.html">reverse_iterator</a> pointing to the beginning of this vector's reversed sequence. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classthrust_1_1reverse__iterator.html">reverse_iterator</a> pointing to the beginning of this vector's reversed sequence. </dd></dl>

</div>
</div>
<a class="anchor" id="a2dd2d733b78ea24c21e5abd24ac1ec6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a const_reverse_iterator pointing to the beginning of this vector's reversed sequence. </p>
<dl class="section return"><dt>Returns</dt><dd>A const_reverse_iterator pointing to the beginning of this vector's reversed sequence. </dd></dl>

</div>
</div>
<a class="anchor" id="a451f3922982e197755978e6530990881"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrust_1_1reverse__iterator.html">reverse_iterator</a> <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a <a class="el" href="classthrust_1_1reverse__iterator.html">reverse_iterator</a> pointing to one element past the last of this vector's reversed sequence. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classthrust_1_1device__vector.html#ab8d7268facdd1dc28ee71520b3cbc9e2">rbegin()</a> + <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a03a48b30549e1934ab7d924d04d7aae7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a const_reverse_iterator pointing to one element past the last of this vector's reversed sequence. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classthrust_1_1device__vector.html#ab8d7268facdd1dc28ee71520b3cbc9e2">rbegin()</a> + <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a94fb215e30e377ff576495b71c833e2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If n is less than or equal to <a class="el" href="classthrust_1_1device__vector.html#af958db3d0ff4b1d05564f9da1e0d0354">capacity()</a>, this call has no effect. Otherwise, this method is a request for allocation of additional memory. If the request is successful, then <a class="el" href="classthrust_1_1device__vector.html#af958db3d0ff4b1d05564f9da1e0d0354">capacity()</a> is greater than or equal to n; otherwise, <a class="el" href="classthrust_1_1device__vector.html#af958db3d0ff4b1d05564f9da1e0d0354">capacity()</a> is unchanged. In either case, <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a> is unchanged. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If n exceeds <a class="el" href="classthrust_1_1device__vector.html#a513a99c29746f120789476eb4e5970ac">max_size()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc3779e3af47e1392ac2ca6f9377e2a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>x</em> = <code>value_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes this vector to the specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>Number of elements this vector should contain. </td></tr>
    <tr><td class="paramname">x</td><td>Data with which new elements should be populated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If n exceeds <a class="el" href="classthrust_1_1device__vector.html#a513a99c29746f120789476eb4e5970ac">max_size()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This method will resize this vector to the specified number of elements. If the number is smaller than this vector's current size this vector is truncated, otherwise this vector is extended and new elements are populated with given data. </p>

</div>
</div>
<a class="anchor" id="a22f3b4f508cdfc3e5e843fdff3fc0ee6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method shrinks the capacity of this vector to exactly fit its elements. </p>

</div>
</div>
<a class="anchor" id="a72802742bce8422af09861ea24bc9bf7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of elements in this vector. </p>

</div>
</div>
<a class="anchor" id="afbb2ba9fb2d40c551598d12d770d68b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method swaps the contents of this vector_base with another vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector with which to swap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>thrust/<a class="el" href="device__vector_8h_source.html">device_vector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 2 2013 22:22:48 for thrust by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
