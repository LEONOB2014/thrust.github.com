<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>thrust: thrust::device_vector&lt; T, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">thrust</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacethrust.html">thrust</a>      </li>
      <li class="navelem"><a class="el" href="classthrust_1_1device__vector.html">device_vector</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">thrust::device_vector&lt; T, Alloc &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__device__containers.html">Device Containers</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="thrust::device_vector" -->
<p><code>#include &lt;<a class="el" href="device__vector_8h_source.html">device_vector.h</a>&gt;</code></p>

<p><a href="classthrust_1_1device__vector-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__host__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#affe7992a8996db6297d541f774ef57e3">device_vector</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__host__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a7c8949a649de0e56c5e38223a6129625">device_vector</a> (size_type n, const value_type &amp;value=value_type())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__host__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a664d90af3a31119caec707c05671fc3e">device_vector</a> (const <a class="el" href="classthrust_1_1device__vector.html">device_vector</a> &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename OtherT , typename OtherAlloc &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a119d447b84e06c53f4017d4abf6ce2c2">device_vector</a> (const <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&lt; OtherT, OtherAlloc &gt; &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename OtherT , typename OtherAlloc &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ <a class="el" href="classthrust_1_1device__vector.html">device_vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a233fe7a300643d7b83af9806d25bdf56">operator=</a> (const <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&lt; OtherT, OtherAlloc &gt; &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename OtherT , typename OtherAlloc &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#ab9b531500f2abba1f6754392de3a9002">device_vector</a> (const std::vector&lt; OtherT, OtherAlloc &gt; &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename OtherT , typename OtherAlloc &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="classthrust_1_1device__vector.html">device_vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a6c39352838fb93f61864fea39b8aea10">operator=</a> (const std::vector&lt; OtherT, OtherAlloc &gt; &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename OtherT , typename OtherAlloc &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a76ce433215d8b29d60498d84f11c346f">device_vector</a> (const <a class="el" href="classthrust_1_1host__vector.html">host_vector</a>&lt; OtherT, OtherAlloc &gt; &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a6330e6d4492822b919b0c2f34101a7c8">device_vector</a> (InputIterator first, InputIterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#acc3779e3af47e1392ac2ca6f9377e2a5">resize</a> (size_type new_size, const value_type &amp;x=value_type())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this vector to the specified number of elements.  <a href="#acc3779e3af47e1392ac2ca6f9377e2a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a513a99c29746f120789476eb4e5970ac">max_size</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a94fb215e30e377ff576495b71c833e2f">reserve</a> (size_type n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If n is less than or equal to <a class="el" href="classthrust_1_1device__vector.html#af958db3d0ff4b1d05564f9da1e0d0354">capacity()</a>, this call has no effect. Otherwise, this method is a request for allocation of additional memory. If the request is successful, then <a class="el" href="classthrust_1_1device__vector.html#af958db3d0ff4b1d05564f9da1e0d0354">capacity()</a> is greater than or equal to n; otherwise, <a class="el" href="classthrust_1_1device__vector.html#af958db3d0ff4b1d05564f9da1e0d0354">capacity()</a> is unchanged. In either case, <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a> is unchanged.  <a href="#a94fb215e30e377ff576495b71c833e2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#af958db3d0ff4b1d05564f9da1e0d0354">capacity</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a22f3b4f508cdfc3e5e843fdff3fc0ee6">shrink_to_fit</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrust_1_1reference.html">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a58941f0d61aabbd377f39766d8ab4d68">operator[]</a> (size_type n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript access to the data contained in this vector_dev.  <a href="#a58941f0d61aabbd377f39766d8ab4d68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a62ef321ccafbcda290b59aafa3c4d05d">operator[]</a> (size_type n) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript read access to the data contained in this vector_dev.  <a href="#a62ef321ccafbcda290b59aafa3c4d05d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a107c4d374ddd0ba4bf96ed5ad875b1de">begin</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a8c968e1de414938ab49d3d88d25ce5a3">begin</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a9ed1fef988525b47367452b1a5131a2f">cbegin</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrust_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#ab8d7268facdd1dc28ee71520b3cbc9e2">rbegin</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a2dd2d733b78ea24c21e5abd24ac1ec6b">rbegin</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#abbe8926d0a8bd2e93baec81cd3efdcc1">crbegin</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#ac534e03ce92587b0e56d7defe1db4a72">end</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a83a0c72634dfa62ebb727c614e946ca8">end</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a20429935a14c2f8cfc8eb668df1da605">cend</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrust_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a451f3922982e197755978e6530990881">rend</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a03a48b30549e1934ab7d924d04d7aae7">rend</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#af2e854a2722ad5ecf8278832de9ff1b0">crend</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#ae0fd61c32fc27934be03d458ab0a5203">front</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrust_1_1reference.html">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a2d7e5a51e0843309c8404ff88efca2e1">front</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a547072f4e0cb5249541d0ebe60d2f6e0">back</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrust_1_1reference.html">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a4666c9f72654e25ae00460ab0597e45a">back</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrust_1_1pointer.html">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a0a59b533bd276a8836e5d5f4ea4c2641">data</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#adda247ed99d80bbd11e59aa64e2a7c82">data</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a242de09fb73c8c18008c2de1b51e9bc5">clear</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#af75977aae033970c26604cae6ce29a82">empty</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a768fd54edd31e07d4a2078b0bb972fea">push_back</a> (const value_type &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a12bc87105a149e4a7d94d728229c254b">pop_back</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#afbb2ba9fb2d40c551598d12d770d68b6">swap</a> (<a class="el" href="classthrust_1_1device__vector.html">device_vector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a0bd666527f0130e1a265739ee2c77d13">erase</a> (iterator pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#ae799093cda17da5619eeb2baf7f2826a">erase</a> (iterator first, iterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#ac8e714f6c50e339d66c1a87bf9c3b161">insert</a> (iterator position, const T &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#aa74f622e3e5e2b71b28b165cfcfd304e">insert</a> (iterator position, size_type n, const T &amp;x)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a29f75c959278cee1ddc11dabee6dd18c">insert</a> (iterator position, InputIterator first, InputIterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a4a0728a800ca1da9bcc6c8bfef019372">assign</a> (size_type n, const T &amp;x)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a19b84992dd2ee6fb05c1813041de032b">assign</a> (InputIterator first, InputIterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html#a3103d80c3f45d75540bba2d9cda20ac3">get_allocator</a> (void) const </td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt;<br/>
class thrust::device_vector&lt; T, Alloc &gt;</h3>

<p>A <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> is a container that supports random access to elements, constant time removal of elements at the end, and linear time insertion and removal of elements at the beginning or in the middle. The number of elements in a <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> may vary dynamically; memory management is automatic. The memory associated with a <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> resides in the memory space of a parallel device.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/Vector.html">http://www.sgi.com/tech/stl/Vector.html</a> </dd>
<dd>
<a class="el" href="classthrust_1_1host__vector.html">host_vector</a> </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="affe7992a8996db6297d541f774ef57e3"></a><!-- doxytag: member="thrust::device_vector::device_vector" ref="affe7992a8996db6297d541f774ef57e3" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::<a class="el" href="classthrust_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This constructor creates an empty <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code>. </p>

</div>
</div>
<a class="anchor" id="a7c8949a649de0e56c5e38223a6129625"></a><!-- doxytag: member="thrust::device_vector::device_vector" ref="a7c8949a649de0e56c5e38223a6129625" args="(size_type n, const value_type &amp;value=value_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::<a class="el" href="classthrust_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>value_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This constructor creates a <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> with copies of an exemplar element. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of elements to initially create. </td></tr>
    <tr><td class="paramname">value</td><td>An element to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a664d90af3a31119caec707c05671fc3e"></a><!-- doxytag: member="thrust::device_vector::device_vector" ref="a664d90af3a31119caec707c05671fc3e" args="(const device_vector &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::<a class="el" href="classthrust_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy constructor copies from an exemplar <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a119d447b84e06c53f4017d4abf6ce2c2"></a><!-- doxytag: member="thrust::device_vector::device_vector" ref="a119d447b84e06c53f4017d4abf6ce2c2" args="(const device_vector&lt; OtherT, OtherAlloc &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OtherT , typename OtherAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::<a class="el" href="classthrust_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&lt; OtherT, OtherAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy constructor copies from an exemplar <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> with different type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9b531500f2abba1f6754392de3a9002"></a><!-- doxytag: member="thrust::device_vector::device_vector" ref="ab9b531500f2abba1f6754392de3a9002" args="(const std::vector&lt; OtherT, OtherAlloc &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OtherT , typename OtherAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::<a class="el" href="classthrust_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; OtherT, OtherAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy constructor copies from an exemplar <code>std::vector</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <code>std::vector</code> to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76ce433215d8b29d60498d84f11c346f"></a><!-- doxytag: member="thrust::device_vector::device_vector" ref="a76ce433215d8b29d60498d84f11c346f" args="(const host_vector&lt; OtherT, OtherAlloc &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OtherT , typename OtherAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::<a class="el" href="classthrust_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrust_1_1host__vector.html">host_vector</a>&lt; OtherT, OtherAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy constructor copies from an exemplar <code><a class="el" href="classthrust_1_1host__vector.html">host_vector</a></code> with possibly different type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <code><a class="el" href="classthrust_1_1host__vector.html">host_vector</a></code> to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6330e6d4492822b919b0c2f34101a7c8"></a><!-- doxytag: member="thrust::device_vector::device_vector" ref="a6330e6d4492822b919b0c2f34101a7c8" args="(InputIterator first, InputIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::<a class="el" href="classthrust_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This constructor builds a <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> from a range. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4a0728a800ca1da9bcc6c8bfef019372"></a><!-- doxytag: member="thrust::device_vector::assign" ref="a4a0728a800ca1da9bcc6c8bfef019372" args="(size_type n, const T &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This version of <code>assign</code> replicates a given exemplar <code>n</code> times into this vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of times to copy <code>x</code>. </td></tr>
    <tr><td class="paramname">x</td><td>The exemplar element to replicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19b84992dd2ee6fb05c1813041de032b"></a><!-- doxytag: member="thrust::device_vector::assign" ref="a19b84992dd2ee6fb05c1813041de032b" args="(InputIterator first, InputIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This version of <code>assign</code> makes this vector a copy of a given input range. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range to copy. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator">Input Iterator</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a547072f4e0cb5249541d0ebe60d2f6e0"></a><!-- doxytag: member="thrust::device_vector::back" ref="a547072f4e0cb5249541d0ebe60d2f6e0" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns a const reference pointing to the last element of this vector. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The last element of this vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a4666c9f72654e25ae00460ab0597e45a"></a><!-- doxytag: member="thrust::device_vector::back" ref="a4666c9f72654e25ae00460ab0597e45a" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrust_1_1reference.html">reference</a> <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns a reference referring to the last element of this vector_dev. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The last element of this vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a107c4d374ddd0ba4bf96ed5ad875b1de"></a><!-- doxytag: member="thrust::device_vector::begin" ref="a107c4d374ddd0ba4bf96ed5ad875b1de" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns an iterator pointing to the beginning of this vector. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>mStart </dd></dl>

</div>
</div>
<a class="anchor" id="a8c968e1de414938ab49d3d88d25ce5a3"></a><!-- doxytag: member="thrust::device_vector::begin" ref="a8c968e1de414938ab49d3d88d25ce5a3" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns a const_iterator pointing to the beginning of this vector. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>mStart </dd></dl>

</div>
</div>
<a class="anchor" id="af958db3d0ff4b1d05564f9da1e0d0354"></a><!-- doxytag: member="thrust::device_vector::capacity" ref="af958db3d0ff4b1d05564f9da1e0d0354" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the number of elements which have been reserved in this vector. </p>

</div>
</div>
<a class="anchor" id="a9ed1fef988525b47367452b1a5131a2f"></a><!-- doxytag: member="thrust::device_vector::cbegin" ref="a9ed1fef988525b47367452b1a5131a2f" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns a const_iterator pointing to the beginning of this vector. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>mStart </dd></dl>

</div>
</div>
<a class="anchor" id="a20429935a14c2f8cfc8eb668df1da605"></a><!-- doxytag: member="thrust::device_vector::cend" ref="a20429935a14c2f8cfc8eb668df1da605" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns a const_iterator pointing to one element past the last of this vector. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classthrust_1_1device__vector.html#a107c4d374ddd0ba4bf96ed5ad875b1de">begin()</a> + <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a242de09fb73c8c18008c2de1b51e9bc5"></a><!-- doxytag: member="thrust::device_vector::clear" ref="a242de09fb73c8c18008c2de1b51e9bc5" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method resizes this vector to 0. </p>

</div>
</div>
<a class="anchor" id="abbe8926d0a8bd2e93baec81cd3efdcc1"></a><!-- doxytag: member="thrust::device_vector::crbegin" ref="abbe8926d0a8bd2e93baec81cd3efdcc1" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::crbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns a const_reverse_iterator pointing to the beginning of this vector's reversed sequence. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A const_reverse_iterator pointing to the beginning of this vector's reversed sequence. </dd></dl>

</div>
</div>
<a class="anchor" id="af2e854a2722ad5ecf8278832de9ff1b0"></a><!-- doxytag: member="thrust::device_vector::crend" ref="af2e854a2722ad5ecf8278832de9ff1b0" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::crend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns a const_reverse_iterator pointing to one element past the last of this vector's reversed sequence. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classthrust_1_1device__vector.html#ab8d7268facdd1dc28ee71520b3cbc9e2">rbegin()</a> + <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a59b533bd276a8836e5d5f4ea4c2641"></a><!-- doxytag: member="thrust::device_vector::data" ref="a0a59b533bd276a8836e5d5f4ea4c2641" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrust_1_1pointer.html">pointer</a> <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns a pointer to this vector's first element. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the first element of this vector. </dd></dl>

</div>
</div>
<a class="anchor" id="adda247ed99d80bbd11e59aa64e2a7c82"></a><!-- doxytag: member="thrust::device_vector::data" ref="adda247ed99d80bbd11e59aa64e2a7c82" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_pointer <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns a const_pointer to this vector's first element. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a const_pointer to the first element of this vector. </dd></dl>

</div>
</div>
<a class="anchor" id="af75977aae033970c26604cae6ce29a82"></a><!-- doxytag: member="thrust::device_vector::empty" ref="af75977aae033970c26604cae6ce29a82" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns true iff <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a> == 0. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a> == 0; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac534e03ce92587b0e56d7defe1db4a72"></a><!-- doxytag: member="thrust::device_vector::end" ref="ac534e03ce92587b0e56d7defe1db4a72" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns an iterator pointing to one element past the last of this vector. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classthrust_1_1device__vector.html#a107c4d374ddd0ba4bf96ed5ad875b1de">begin()</a> + <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a83a0c72634dfa62ebb727c614e946ca8"></a><!-- doxytag: member="thrust::device_vector::end" ref="a83a0c72634dfa62ebb727c614e946ca8" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns a const_iterator pointing to one element past the last of this vector. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classthrust_1_1device__vector.html#a107c4d374ddd0ba4bf96ed5ad875b1de">begin()</a> + <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bd666527f0130e1a265739ee2c77d13"></a><!-- doxytag: member="thrust::device_vector::erase" ref="a0bd666527f0130e1a265739ee2c77d13" args="(iterator pos)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method removes the element at position pos. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the element of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator pointing to the new location of the element that followed the element at position pos. </dd></dl>

</div>
</div>
<a class="anchor" id="ae799093cda17da5619eeb2baf7f2826a"></a><!-- doxytag: member="thrust::device_vector::erase" ref="ae799093cda17da5619eeb2baf7f2826a" args="(iterator first, iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method removes the range of elements [first,last) from this vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range of elements to remove. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range of elements to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator pointing to the new location of the element that followed the last element in the sequence [first,last). </dd></dl>

</div>
</div>
<a class="anchor" id="ae0fd61c32fc27934be03d458ab0a5203"></a><!-- doxytag: member="thrust::device_vector::front" ref="ae0fd61c32fc27934be03d458ab0a5203" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns a const_reference referring to the first element of this vector. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first element of this vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d7e5a51e0843309c8404ff88efca2e1"></a><!-- doxytag: member="thrust::device_vector::front" ref="a2d7e5a51e0843309c8404ff88efca2e1" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrust_1_1reference.html">reference</a> <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns a reference pointing to the first element of this vector. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first element of this vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a3103d80c3f45d75540bba2d9cda20ac3"></a><!-- doxytag: member="thrust::device_vector::get_allocator" ref="a3103d80c3f45d75540bba2d9cda20ac3" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns a copy of this vector's allocator. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A copy of the alloctor used by this vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8e714f6c50e339d66c1a87bf9c3b161"></a><!-- doxytag: member="thrust::device_vector::insert" ref="ac8e714f6c50e339d66c1a87bf9c3b161" args="(iterator position, const T &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method inserts a single copy of a given exemplar value at the specified position in this vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The insertion position. </td></tr>
    <tr><td class="paramname">x</td><td>The exemplar element to copy &amp; insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator pointing to the newly inserted element. </dd></dl>

</div>
</div>
<a class="anchor" id="a29f75c959278cee1ddc11dabee6dd18c"></a><!-- doxytag: member="thrust::device_vector::insert" ref="a29f75c959278cee1ddc11dabee6dd18c" args="(iterator position, InputIterator first, InputIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method inserts a copy of an input range at the specified position in this vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The insertion position. </td></tr>
    <tr><td class="paramname">first</td><td>The beginning of the range to copy. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator</td><td>is a model of &lt;a href="http://www.sgi.com/tech/stl/InputIterator.html&gt;Input Iterator&lt;/a&gt;,
                        and \p InputIterator's \c value_type is a model of &lt;a href="<a href="http://www.sgi.com/tech/stl/Assignable.html">http://www.sgi.com/tech/stl/Assignable.html</a>"&gt;Assignable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa74f622e3e5e2b71b28b165cfcfd304e"></a><!-- doxytag: member="thrust::device_vector::insert" ref="aa74f622e3e5e2b71b28b165cfcfd304e" args="(iterator position, size_type n, const T &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method inserts a copy of an exemplar value to a range at the specified position in this vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The insertion position </td></tr>
    <tr><td class="paramname">n</td><td>The number of insertions to perform. </td></tr>
    <tr><td class="paramname">x</td><td>The value to replicate and insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a513a99c29746f120789476eb4e5970ac"></a><!-- doxytag: member="thrust::device_vector::max_size" ref="a513a99c29746f120789476eb4e5970ac" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a> of the largest possible vector. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The largest possible return value of <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a233fe7a300643d7b83af9806d25bdf56"></a><!-- doxytag: member="thrust::device_vector::operator=" ref="a233fe7a300643d7b83af9806d25bdf56" args="(const device_vector&lt; OtherT, OtherAlloc &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OtherT , typename OtherAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&amp; <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&lt; OtherT, OtherAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign operator copies from an exemplar <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> with different type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> to copy. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classthrust_1_1device__vector.html#a6c39352838fb93f61864fea39b8aea10">thrust::device_vector&lt; T, Alloc &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a6c39352838fb93f61864fea39b8aea10"></a><!-- doxytag: member="thrust::device_vector::operator=" ref="a6c39352838fb93f61864fea39b8aea10" args="(const std::vector&lt; OtherT, OtherAlloc &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OtherT , typename OtherAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&amp; <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; OtherT, OtherAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign operator copies from an exemplar <code>std::vector</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <code>std::vector</code> to copy. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classthrust_1_1device__vector.html#a233fe7a300643d7b83af9806d25bdf56">thrust::device_vector&lt; T, Alloc &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a58941f0d61aabbd377f39766d8ab4d68"></a><!-- doxytag: member="thrust::device_vector::operator[]" ref="a58941f0d61aabbd377f39766d8ab4d68" args="(size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrust_1_1reference.html">reference</a> <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subscript access to the data contained in this vector_dev. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Read/write reference to data.</dd></dl>
<p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. </p>

</div>
</div>
<a class="anchor" id="a62ef321ccafbcda290b59aafa3c4d05d"></a><!-- doxytag: member="thrust::device_vector::operator[]" ref="a62ef321ccafbcda290b59aafa3c4d05d" args="(size_type n) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subscript read access to the data contained in this vector_dev. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Read reference to data.</dd></dl>
<p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. </p>

</div>
</div>
<a class="anchor" id="a12bc87105a149e4a7d94d728229c254b"></a><!-- doxytag: member="thrust::device_vector::pop_back" ref="a12bc87105a149e4a7d94d728229c254b" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::pop_back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method erases the last element of this vector, invalidating all iterators and references to it. </p>

</div>
</div>
<a class="anchor" id="a768fd54edd31e07d4a2078b0bb972fea"></a><!-- doxytag: member="thrust::device_vector::push_back" ref="a768fd54edd31e07d4a2078b0bb972fea" args="(const value_type &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method appends the given element to the end of this vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The element to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8d7268facdd1dc28ee71520b3cbc9e2"></a><!-- doxytag: member="thrust::device_vector::rbegin" ref="ab8d7268facdd1dc28ee71520b3cbc9e2" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrust_1_1reverse__iterator.html">reverse_iterator</a> <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns a <a class="el" href="classthrust_1_1reverse__iterator.html">reverse_iterator</a> pointing to the beginning of this vector's reversed sequence. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classthrust_1_1reverse__iterator.html">reverse_iterator</a> pointing to the beginning of this vector's reversed sequence. </dd></dl>

</div>
</div>
<a class="anchor" id="a2dd2d733b78ea24c21e5abd24ac1ec6b"></a><!-- doxytag: member="thrust::device_vector::rbegin" ref="a2dd2d733b78ea24c21e5abd24ac1ec6b" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns a const_reverse_iterator pointing to the beginning of this vector's reversed sequence. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A const_reverse_iterator pointing to the beginning of this vector's reversed sequence. </dd></dl>

</div>
</div>
<a class="anchor" id="a03a48b30549e1934ab7d924d04d7aae7"></a><!-- doxytag: member="thrust::device_vector::rend" ref="a03a48b30549e1934ab7d924d04d7aae7" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns a const_reverse_iterator pointing to one element past the last of this vector's reversed sequence. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classthrust_1_1device__vector.html#ab8d7268facdd1dc28ee71520b3cbc9e2">rbegin()</a> + <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a451f3922982e197755978e6530990881"></a><!-- doxytag: member="thrust::device_vector::rend" ref="a451f3922982e197755978e6530990881" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrust_1_1reverse__iterator.html">reverse_iterator</a> <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns a <a class="el" href="classthrust_1_1reverse__iterator.html">reverse_iterator</a> pointing to one element past the last of this vector's reversed sequence. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classthrust_1_1device__vector.html#ab8d7268facdd1dc28ee71520b3cbc9e2">rbegin()</a> + <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a94fb215e30e377ff576495b71c833e2f"></a><!-- doxytag: member="thrust::device_vector::reserve" ref="a94fb215e30e377ff576495b71c833e2f" args="(size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If n is less than or equal to <a class="el" href="classthrust_1_1device__vector.html#af958db3d0ff4b1d05564f9da1e0d0354">capacity()</a>, this call has no effect. Otherwise, this method is a request for allocation of additional memory. If the request is successful, then <a class="el" href="classthrust_1_1device__vector.html#af958db3d0ff4b1d05564f9da1e0d0354">capacity()</a> is greater than or equal to n; otherwise, <a class="el" href="classthrust_1_1device__vector.html#af958db3d0ff4b1d05564f9da1e0d0354">capacity()</a> is unchanged. In either case, <a class="el" href="classthrust_1_1device__vector.html#a72802742bce8422af09861ea24bc9bf7">size()</a> is unchanged. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If n exceeds <a class="el" href="classthrust_1_1device__vector.html#a513a99c29746f120789476eb4e5970ac">max_size()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc3779e3af47e1392ac2ca6f9377e2a5"></a><!-- doxytag: member="thrust::device_vector::resize" ref="acc3779e3af47e1392ac2ca6f9377e2a5" args="(size_type new_size, const value_type &amp;x=value_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>x</em> = <code>value_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resizes this vector to the specified number of elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>Number of elements this vector should contain. </td></tr>
    <tr><td class="paramname">x</td><td>Data with which new elements should be populated. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If n exceeds <a class="el" href="classthrust_1_1device__vector.html#a513a99c29746f120789476eb4e5970ac">max_size()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This method will resize this vector to the specified number of elements. If the number is smaller than this vector's current size this vector is truncated, otherwise this vector is extended and new elements are populated with given data. </p>

</div>
</div>
<a class="anchor" id="a22f3b4f508cdfc3e5e843fdff3fc0ee6"></a><!-- doxytag: member="thrust::device_vector::shrink_to_fit" ref="a22f3b4f508cdfc3e5e843fdff3fc0ee6" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method shrinks the capacity of this vector to exactly fit its elements. </p>

</div>
</div>
<a class="anchor" id="a72802742bce8422af09861ea24bc9bf7"></a><!-- doxytag: member="thrust::device_vector::size" ref="a72802742bce8422af09861ea24bc9bf7" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the number of elements in this vector. </p>

</div>
</div>
<a class="anchor" id="afbb2ba9fb2d40c551598d12d770d68b6"></a><!-- doxytag: member="thrust::device_vector::swap" ref="afbb2ba9fb2d40c551598d12d770d68b6" args="(device_vector &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = thrust::device_malloc_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector</a>&lt; T, Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method swaps the contents of this vector_base with another vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector with which to swap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="device__vector_8h_source.html">device_vector.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon May 7 2012 15:15:01 for thrust by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
