<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>thrust: Prefix Sums</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">thrust
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Prefix Sums</div>  </div>
<div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a></div></div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__segmentedprefixsums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html">Segmented Prefix Sums</a></td></tr>
<tr class="memitem:group__transformed__prefixsums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformed__prefixsums.html">Transformed Prefix Sums</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga32e405cc5a138a6ef20dc2000b3f42df"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga32e405cc5a138a6ef20dc2000b3f42df"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#ga32e405cc5a138a6ef20dc2000b3f42df">thrust::inclusive_scan</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="memitem:gad57155adfbf01ba6660839aafe16ad71"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gad57155adfbf01ba6660839aafe16ad71"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#gad57155adfbf01ba6660839aafe16ad71">thrust::inclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="memitem:ga3ee07457799ed36979f02d92ef0b25f7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator , typename OutputIterator , typename AssociativeOperator &gt; </td></tr>
<tr class="memitem:ga3ee07457799ed36979f02d92ef0b25f7"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#ga3ee07457799ed36979f02d92ef0b25f7">thrust::inclusive_scan</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator first, InputIterator last, OutputIterator result, AssociativeOperator binary_op)</td></tr>
<tr class="memitem:ga7109170b96a48fab736e52b75f423464"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename AssociativeOperator &gt; </td></tr>
<tr class="memitem:ga7109170b96a48fab736e52b75f423464"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#ga7109170b96a48fab736e52b75f423464">thrust::inclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, AssociativeOperator binary_op)</td></tr>
<tr class="memitem:gae5d3cdb73f9532b0a9692624988f3ab1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gae5d3cdb73f9532b0a9692624988f3ab1"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#gae5d3cdb73f9532b0a9692624988f3ab1">thrust::exclusive_scan</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="memitem:ga333bd4f34742dcf68d3ac5a0933f67db"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga333bd4f34742dcf68d3ac5a0933f67db"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#ga333bd4f34742dcf68d3ac5a0933f67db">thrust::exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="memitem:ga89d7b142693ad061fb5b5ba6b1f82c67"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator , typename OutputIterator , typename T &gt; </td></tr>
<tr class="memitem:ga89d7b142693ad061fb5b5ba6b1f82c67"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#ga89d7b142693ad061fb5b5ba6b1f82c67">thrust::exclusive_scan</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator first, InputIterator last, OutputIterator result, T init)</td></tr>
<tr class="memitem:ga3d973b51246f3d869339c08e3cbdc6fb"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename T &gt; </td></tr>
<tr class="memitem:ga3d973b51246f3d869339c08e3cbdc6fb"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#ga3d973b51246f3d869339c08e3cbdc6fb">thrust::exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, T init)</td></tr>
<tr class="memitem:ga8dbe92b545e14800f567c69624238d17"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator , typename OutputIterator , typename T , typename AssociativeOperator &gt; </td></tr>
<tr class="memitem:ga8dbe92b545e14800f567c69624238d17"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#ga8dbe92b545e14800f567c69624238d17">thrust::exclusive_scan</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator first, InputIterator last, OutputIterator result, T init, AssociativeOperator binary_op)</td></tr>
<tr class="memitem:gaa3f981950f16c9dae693590b79a9ff90"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename T , typename AssociativeOperator &gt; </td></tr>
<tr class="memitem:gaa3f981950f16c9dae693590b79a9ff90"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#gaa3f981950f16c9dae693590b79a9ff90">thrust::exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, T init, AssociativeOperator binary_op)</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<h2>Function Documentation</h2>
<a class="anchor" id="gae5d3cdb73f9532b0a9692624988f3ab1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::exclusive_scan </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>exclusive_scan</code> computes an exclusive prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. More precisely, <code>0</code> is assigned to <code>*result</code> and the sum of <code>0</code> and <code>*first</code> is assigned to <code>*(result + 1)</code>, and so on. This version of <code>exclusive_scan</code> assumes plus as the associative operator and <code>0</code> as the initial value. When the input and output sequences are the same, the scan is performed in-place.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first</td><td>The beginning of the input sequence. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the input sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>x + y</code> is defined. If <code>T</code> is <code>OutputIterator's</code> <code>value_type</code>, then <code>T(0)</code> is defined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>exclusive_scan</code> to compute an in-place prefix sum using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html" title="Functions for computing prefix sums.">thrust/scan.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html" title="Thrust execution policies.">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">int data[6] = {1, 0, 2, 2, 1, 3};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__prefixsums.html#gae5d3cdb73f9532b0a9692624988f3ab1">thrust::exclusive_scan</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, data, data + 6, data); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// data is now {0, 1, 1, 3, 5, 6}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/partial_sum.html">http://www.sgi.com/tech/stl/partial_sum.html</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga333bd4f34742dcf68d3ac5a0933f67db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::exclusive_scan </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>exclusive_scan</code> computes an exclusive prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. More precisely, <code>0</code> is assigned to <code>*result</code> and the sum of <code>0</code> and <code>*first</code> is assigned to <code>*(result + 1)</code>, and so on. This version of <code>exclusive_scan</code> assumes plus as the associative operator and <code>0</code> as the initial value. When the input and output sequences are the same, the scan is performed in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the input sequence. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the input sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>x + y</code> is defined. If <code>T</code> is <code>OutputIterator's</code> <code>value_type</code>, then <code>T(0)</code> is defined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>exclusive_scan</code> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html" title="Functions for computing prefix sums.">thrust/scan.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> data[6] = {1, 0, 2, 2, 1, 3};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__prefixsums.html#gae5d3cdb73f9532b0a9692624988f3ab1">thrust::exclusive_scan</a>(data, data + 6, data); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// data is now {0, 1, 1, 3, 5, 6}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/partial_sum.html">http://www.sgi.com/tech/stl/partial_sum.html</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga89d7b142693ad061fb5b5ba6b1f82c67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator , typename OutputIterator , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::exclusive_scan </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>exclusive_scan</code> computes an exclusive prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. More precisely, <code>init</code> is assigned to <code>*result</code> and the sum of <code>init</code> and <code>*first</code> is assigned to <code>*(result + 1)</code>, and so on. This version of <code>exclusive_scan</code> assumes plus as the associative operator but requires an initial value <code>init</code>. When the input and output sequences are the same, the scan is performed in-place.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first</td><td>The beginning of the input sequence. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the input sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output sequence. </td></tr>
    <tr><td class="paramname">init</td><td>The initial value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>x + y</code> is defined. </td></tr>
    <tr><td class="paramname">T</td><td>is convertible to <code>OutputIterator's</code> <code>value_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>exclusive_scan</code> to compute an in-place prefix sum using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html" title="Functions for computing prefix sums.">thrust/scan.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html" title="Thrust execution policies.">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> data[6] = {1, 0, 2, 2, 1, 3};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__prefixsums.html#gae5d3cdb73f9532b0a9692624988f3ab1">thrust::exclusive_scan</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, data, data + 6, data, 4); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// data is now {4, 5, 5, 7, 9, 10}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/partial_sum.html">http://www.sgi.com/tech/stl/partial_sum.html</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d973b51246f3d869339c08e3cbdc6fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::exclusive_scan </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>exclusive_scan</code> computes an exclusive prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. More precisely, <code>init</code> is assigned to <code>*result</code> and the sum of <code>init</code> and <code>*first</code> is assigned to <code>*(result + 1)</code>, and so on. This version of <code>exclusive_scan</code> assumes plus as the associative operator but requires an initial value <code>init</code>. When the input and output sequences are the same, the scan is performed in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the input sequence. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the input sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output sequence. </td></tr>
    <tr><td class="paramname">init</td><td>The initial value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>x + y</code> is defined. </td></tr>
    <tr><td class="paramname">T</td><td>is convertible to <code>OutputIterator's</code> <code>value_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>exclusive_scan</code> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html" title="Functions for computing prefix sums.">thrust/scan.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> data[6] = {1, 0, 2, 2, 1, 3};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__prefixsums.html#gae5d3cdb73f9532b0a9692624988f3ab1">thrust::exclusive_scan</a>(data, data + 6, data, 4); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// data is now {4, 5, 5, 7, 9, 10}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/partial_sum.html">http://www.sgi.com/tech/stl/partial_sum.html</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8dbe92b545e14800f567c69624238d17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator , typename OutputIterator , typename T , typename AssociativeOperator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::exclusive_scan </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssociativeOperator&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>exclusive_scan</code> computes an exclusive prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. More precisely, <code>init</code> is assigned to <code>*result</code> and the value <code>binary_op(init, *first)</code> is assigned to <code>*(result + 1)</code>, and so on. This version of the function requires both and associative operator and an initial value <code>init</code>. When the input and output sequences are the same, the scan is performed in-place.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first</td><td>The beginning of the input sequence. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the input sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output sequence. </td></tr>
    <tr><td class="paramname">init</td><td>The initial value. </td></tr>
    <tr><td class="paramname">binary_op</td><td>The associatve operator used to 'sum' values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a> and <code>OutputIterator's</code> <code>value_type</code> is convertible to both <code>AssociativeOperator's</code> <code>first_argument_type</code> and <code>second_argument_type</code>. </td></tr>
    <tr><td class="paramname">T</td><td>is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">AssociativeOperator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">Binary Function</a> and <code>AssociativeOperator's</code> <code>result_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>exclusive_scan</code> to compute an in-place prefix sum using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html" title="Functions for computing prefix sums.">thrust/scan.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html" title="Function objects and tools for manipulating them.">thrust/functional.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html" title="Thrust execution policies.">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">int data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1maximum.html">thrust::maximum&lt;int&gt;</a> binary_op;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__prefixsums.html#gae5d3cdb73f9532b0a9692624988f3ab1">thrust::exclusive_scan</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, data, data + 10, data, 1, binary_op); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// data is now {1, 1, 1, 2, 2, 2, 4, 4, 4, 4 }</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/partial_sum.html">http://www.sgi.com/tech/stl/partial_sum.html</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa3f981950f16c9dae693590b79a9ff90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename T , typename AssociativeOperator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::exclusive_scan </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssociativeOperator&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>exclusive_scan</code> computes an exclusive prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. More precisely, <code>init</code> is assigned to <code>*result</code> and the value <code>binary_op(init, *first)</code> is assigned to <code>*(result + 1)</code>, and so on. This version of the function requires both and associative operator and an initial value <code>init</code>. When the input and output sequences are the same, the scan is performed in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the input sequence. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the input sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output sequence. </td></tr>
    <tr><td class="paramname">init</td><td>The initial value. </td></tr>
    <tr><td class="paramname">binary_op</td><td>The associatve operator used to 'sum' values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a> and <code>OutputIterator's</code> <code>value_type</code> is convertible to both <code>AssociativeOperator's</code> <code>first_argument_type</code> and <code>second_argument_type</code>. </td></tr>
    <tr><td class="paramname">T</td><td>is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">AssociativeOperator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">Binary Function</a> and <code>AssociativeOperator's</code> <code>result_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>exclusive_scan</code> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html" title="Functions for computing prefix sums.">thrust/scan.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html" title="Function objects and tools for manipulating them.">thrust/functional.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1maximum.html">thrust::maximum&lt;int&gt;</a> binary_op;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__prefixsums.html#gae5d3cdb73f9532b0a9692624988f3ab1">thrust::exclusive_scan</a>(data, data + 10, data, 1, binary_op); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// data is now {1, 1, 1, 2, 2, 2, 4, 4, 4, 4 }</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/partial_sum.html">http://www.sgi.com/tech/stl/partial_sum.html</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga32e405cc5a138a6ef20dc2000b3f42df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::inclusive_scan </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>inclusive_scan</code> computes an inclusive prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. More precisely, <code>*first</code> is assigned to <code>*result</code> and the sum of <code>*first</code> and <code>*(first + 1)</code> is assigned to <code>*(result + 1)</code>, and so on. This version of <code>inclusive_scan</code> assumes plus as the associative operator. When the input and output sequences are the same, the scan is performed in-place.</p>
<p><code>inclusive_scan</code> is similar to <code>std::partial_sum</code> in the STL. The primary difference between the two functions is that <code>std::partial_sum</code> guarantees a serial summation order, while <code>inclusive_scan</code> requires associativity of the binary operation to parallelize the prefix sum.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first</td><td>The beginning of the input sequence. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the input sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>x + y</code> is defined. If <code>T</code> is <code>OutputIterator's</code> <code>value_type</code>, then <code>T(0)</code> is defined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>inclusive_scan</code> to compute an in-place prefix sum using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html" title="Functions for computing prefix sums.">thrust/scan.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html" title="Thrust execution policies.">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">int data[6] = {1, 0, 2, 2, 1, 3};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__prefixsums.html#ga32e405cc5a138a6ef20dc2000b3f42df">thrust::inclusive_scan</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, data, data + 6, data); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// data is now {1, 1, 3, 5, 6, 9}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/partial_sum.html">http://www.sgi.com/tech/stl/partial_sum.html</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad57155adfbf01ba6660839aafe16ad71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::inclusive_scan </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>inclusive_scan</code> computes an inclusive prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. More precisely, <code>*first</code> is assigned to <code>*result</code> and the sum of <code>*first</code> and <code>*(first + 1)</code> is assigned to <code>*(result + 1)</code>, and so on. This version of <code>inclusive_scan</code> assumes plus as the associative operator. When the input and output sequences are the same, the scan is performed in-place.</p>
<p><code>inclusive_scan</code> is similar to <code>std::partial_sum</code> in the STL. The primary difference between the two functions is that <code>std::partial_sum</code> guarantees a serial summation order, while <code>inclusive_scan</code> requires associativity of the binary operation to parallelize the prefix sum.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the input sequence. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the input sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>x + y</code> is defined. If <code>T</code> is <code>OutputIterator's</code> <code>value_type</code>, then <code>T(0)</code> is defined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>inclusive_scan</code> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html" title="Functions for computing prefix sums.">thrust/scan.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> data[6] = {1, 0, 2, 2, 1, 3};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__prefixsums.html#ga32e405cc5a138a6ef20dc2000b3f42df">thrust::inclusive_scan</a>(data, data + 6, data); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// data is now {1, 1, 3, 5, 6, 9}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/partial_sum.html">http://www.sgi.com/tech/stl/partial_sum.html</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ee07457799ed36979f02d92ef0b25f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator , typename OutputIterator , typename AssociativeOperator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::inclusive_scan </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssociativeOperator&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>inclusive_scan</code> computes an inclusive prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. When the input and output sequences are the same, the scan is performed in-place.</p>
<p><code>inclusive_scan</code> is similar to <code>std::partial_sum</code> in the STL. The primary difference between the two functions is that <code>std::partial_sum</code> guarantees a serial summation order, while <code>inclusive_scan</code> requires associativity of the binary operation to parallelize the prefix sum.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first</td><td>The beginning of the input sequence. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the input sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output sequence. </td></tr>
    <tr><td class="paramname">binary_op</td><td>The associatve operator used to 'sum' values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a> and <code>OutputIterator's</code> <code>value_type</code> is convertible to both <code>AssociativeOperator's</code> <code>first_argument_type</code> and <code>second_argument_type</code>. </td></tr>
    <tr><td class="paramname">AssociativeOperator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">Binary Function</a> and <code>AssociativeOperator's</code> <code>result_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>inclusive_scan</code> to compute an in-place prefix sum using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1maximum.html">thrust::maximum&lt;int&gt;</a> binary_op;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__prefixsums.html#ga32e405cc5a138a6ef20dc2000b3f42df">thrust::inclusive_scan</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, data, data + 10, data, binary_op); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// data is now {-5, 0, 2, 2, 2, 4, 4, 4, 4, 8}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/partial_sum.html">http://www.sgi.com/tech/stl/partial_sum.html</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7109170b96a48fab736e52b75f423464"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename AssociativeOperator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::inclusive_scan </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssociativeOperator&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>inclusive_scan</code> computes an inclusive prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. When the input and output sequences are the same, the scan is performed in-place.</p>
<p><code>inclusive_scan</code> is similar to <code>std::partial_sum</code> in the STL. The primary difference between the two functions is that <code>std::partial_sum</code> guarantees a serial summation order, while <code>inclusive_scan</code> requires associativity of the binary operation to parallelize the prefix sum.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the input sequence. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the input sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output sequence. </td></tr>
    <tr><td class="paramname">binary_op</td><td>The associatve operator used to 'sum' values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a> and <code>OutputIterator's</code> <code>value_type</code> is convertible to both <code>AssociativeOperator's</code> <code>first_argument_type</code> and <code>second_argument_type</code>. </td></tr>
    <tr><td class="paramname">AssociativeOperator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">Binary Function</a> and <code>AssociativeOperator's</code> <code>result_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>inclusive_scan</code> </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1maximum.html">thrust::maximum&lt;int&gt;</a> binary_op;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__prefixsums.html#ga32e405cc5a138a6ef20dc2000b3f42df">thrust::inclusive_scan</a>(data, data + 10, data, binary_op); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// data is now {-5, 0, 2, 2, 2, 4, 4, 4, 4, 8}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/partial_sum.html">http://www.sgi.com/tech/stl/partial_sum.html</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 2 2013 22:22:48 for thrust by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
