<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>thrust: Segmented Prefix Sums</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">thrust</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Segmented Prefix Sums</div>  </div>
<div class="ingroups"><a class="el" href="group__prefixsums.html">Prefix Sums</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga9e464dc32ccff03b66e7d810634c9a26">thrust::inclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga3bccd2038b9f2a46d8908e085fbb5dc6">thrust::inclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryPredicate , typename AssociativeOperator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga05d4b099d9afea2762777bf85a3316de">thrust::inclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred, AssociativeOperator binary_op)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga73ac77aacdcc81847c088827b9e85ccf">thrust::exclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga057e88bffbaef810bceed8d24644941b">thrust::exclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga80fedeb60b3990df6429a869fb840fe8">thrust::exclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T , typename BinaryPredicate , typename AssociativeOperator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga36951c72c1a4a646fbe3ccdb1e94473b">thrust::exclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred, AssociativeOperator binary_op)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga73ac77aacdcc81847c088827b9e85ccf"></a><!-- doxytag: member="thrust::exclusive_scan_by_key" ref="ga73ac77aacdcc81847c088827b9e85ccf" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::exclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>exclusive_scan_by_key</code> computes an exclusive segmented prefix</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the value <code>0</code> to initialize the exclusive scan operation.</p>
<p>This version of <code>exclusive_scan_by_key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.</p>
<p>This version of <code>exclusive_scan_by_key</code> assumes <code><a class="el" href="structthrust_1_1equal__to.html">equal_to</a></code> as the binary predicate used to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1</code> belong to the same segment if <code>*i == *(i+1)</code>, and belong to different segments otherwise.</p>
<p>Refer to the most general form of <code>exclusive_scan_by_key</code> for additional details.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>exclusive_scan_by_key</code>.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="scan_8h.html" title="Functions for computing prefix sums.">thrust/scan.h</a>&gt;</span>
  
  <span class="keywordtype">int</span> keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
  <span class="keywordtype">int</span> vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

  <a class="code" href="group__segmentedprefixsums.html#ga73ac77aacdcc81847c088827b9e85ccf">thrust::exclusive_scan_by_key</a>(key, key + 10, vals, vals); <span class="comment">// in-place scan</span>

  <span class="comment">// vals is now {0, 1, 2, 0, 1, 0, 0, 1, 2, 3};</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__prefixsums.html#gadb94a5315b0fdf69fc4f90b0e361ac85">exclusive_scan</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga36951c72c1a4a646fbe3ccdb1e94473b"></a><!-- doxytag: member="thrust::exclusive_scan_by_key" ref="ga36951c72c1a4a646fbe3ccdb1e94473b" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred, AssociativeOperator binary_op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T , typename BinaryPredicate , typename AssociativeOperator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::exclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssociativeOperator&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>exclusive_scan_by_key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the value <code>init</code> to initialize the exclusive scan operation.</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the binary predicate <code>binary_pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary_pred(*i, *(i+1))</code> is true, and belong to different segments otherwise.</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the associative operator <code>binary_op</code> to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence. </td></tr>
    <tr><td class="paramname">init</td><td>The initial of the exclusive sum value. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>The binary predicate used to determine equality of keys. </td></tr>
    <tr><td class="paramname">binary_op</td><td>The associatve operator used to 'sum' values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the output sequence.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator2's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>binary_op(x,y)</code> is defined. </td></tr>
    <tr><td class="paramname">T</td><td>is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">BinaryPredicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">Binary Predicate</a>. </td></tr>
    <tr><td class="paramname">AssociativeOperator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">Binary Function</a> and <code>AssociativeOperator's</code> <code>result_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>exclusive_scan_by_key</code> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="scan_8h.html" title="Functions for computing prefix sums.">thrust/scan.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="functional_8h.html" title="Function objects and tools for manipulating them.">thrust/functional.h</a>&gt;</span>
  
  <span class="keywordtype">int</span> keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
  <span class="keywordtype">int</span> vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

  <span class="keywordtype">int</span> init = 5;

  <a class="code" href="structthrust_1_1equal__to.html">thrust::equal_to&lt;int&gt;</a> binary_pred;
  <a class="code" href="structthrust_1_1plus.html">thrust::plus&lt;int&gt;</a>     binary_op;

  <a class="code" href="group__segmentedprefixsums.html#ga73ac77aacdcc81847c088827b9e85ccf">thrust::exclusive_scan_by_key</a>(key, key + 10, vals, vals, init, binary_pred, binary_op); <span class="comment">// in-place scan</span>

  <span class="comment">// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__prefixsums.html#gadb94a5315b0fdf69fc4f90b0e361ac85">exclusive_scan</a> </dd>
<dd>
<a class="el" href="group__segmentedprefixsums.html#ga9e464dc32ccff03b66e7d810634c9a26">inclusive_scan_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga057e88bffbaef810bceed8d24644941b"></a><!-- doxytag: member="thrust::exclusive_scan_by_key" ref="ga057e88bffbaef810bceed8d24644941b" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::exclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>exclusive_scan_by_key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the value <code>init</code> to initialize the exclusive scan operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence. </td></tr>
    <tr><td class="paramname">init</td><td>The initial of the exclusive sum value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the output sequence.</dd></dl>
<p>The following code snippet demonstrates how to use <code>exclusive_scan_by_key</code> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="scan_8h.html" title="Functions for computing prefix sums.">thrust/scan.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="functional_8h.html" title="Function objects and tools for manipulating them.">thrust/functional.h</a>&gt;</span>
  
  <span class="keywordtype">int</span> keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
  <span class="keywordtype">int</span> vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

  <span class="keywordtype">int</span> init = 5;

  <a class="code" href="group__segmentedprefixsums.html#ga73ac77aacdcc81847c088827b9e85ccf">thrust::exclusive_scan_by_key</a>(key, key + 10, vals, vals, init); <span class="comment">// in-place scan</span>

  <span class="comment">// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__prefixsums.html#gadb94a5315b0fdf69fc4f90b0e361ac85">exclusive_scan</a> </dd>
<dd>
<a class="el" href="group__segmentedprefixsums.html#ga9e464dc32ccff03b66e7d810634c9a26">inclusive_scan_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga80fedeb60b3990df6429a869fb840fe8"></a><!-- doxytag: member="thrust::exclusive_scan_by_key" ref="ga80fedeb60b3990df6429a869fb840fe8" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T , typename BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::exclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>exclusive_scan_by_key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the value <code>init</code> to initialize the exclusive scan operation.</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the binary predicate <code>binary_pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary_pred(*i, *(i+1))</code> is true, and belong to different segments otherwise.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence. </td></tr>
    <tr><td class="paramname">init</td><td>The initial of the exclusive sum value. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>The binary predicate used to determine equality of keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the output sequence.</dd></dl>
<p>The following code snippet demonstrates how to use <code>exclusive_scan_by_key</code> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="scan_8h.html" title="Functions for computing prefix sums.">thrust/scan.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="functional_8h.html" title="Function objects and tools for manipulating them.">thrust/functional.h</a>&gt;</span>
  
  <span class="keywordtype">int</span> keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
  <span class="keywordtype">int</span> vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

  <span class="keywordtype">int</span> init = 5;

  <a class="code" href="structthrust_1_1equal__to.html">thrust::equal_to&lt;int&gt;</a> binary_pred;

  <a class="code" href="group__segmentedprefixsums.html#ga73ac77aacdcc81847c088827b9e85ccf">thrust::exclusive_scan_by_key</a>(key, key + 10, vals, vals, init, binary_pred); <span class="comment">// in-place scan</span>

  <span class="comment">// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__prefixsums.html#gadb94a5315b0fdf69fc4f90b0e361ac85">exclusive_scan</a> </dd>
<dd>
<a class="el" href="group__segmentedprefixsums.html#ga9e464dc32ccff03b66e7d810634c9a26">inclusive_scan_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3bccd2038b9f2a46d8908e085fbb5dc6"></a><!-- doxytag: member="thrust::inclusive_scan_by_key" ref="ga3bccd2038b9f2a46d8908e085fbb5dc6" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::inclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>inclusive_scan_by_key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.</p>
<p>This version of <code>inclusive_scan_by_key</code> uses the binary predicate <code>pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary_pred(*i, *(i+1))</code> is true, and belong to different segments otherwise.</p>
<p>This version of <code>inclusive_scan_by_key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>The binary predicate used to determine equality of keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the output sequence.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator2's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>binary_op(x,y)</code> is defined. </td></tr>
    <tr><td class="paramname">BinaryPredicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">Binary Predicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>inclusive_scan_by_key</code> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="scan_8h.html" title="Functions for computing prefix sums.">thrust/scan.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="functional_8h.html" title="Function objects and tools for manipulating them.">thrust/functional.h</a>&gt;</span>
  
  <span class="keywordtype">int</span> data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
  <span class="keywordtype">int</span> keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};

  <a class="code" href="structthrust_1_1equal__to.html">thrust::equal_to&lt;int&gt;</a> binary_pred;

  <a class="code" href="group__segmentedprefixsums.html#ga9e464dc32ccff03b66e7d810634c9a26">thrust::inclusive_scan_by_key</a>(keys, keys + 10, vals, vals, binary_pred); <span class="comment">// in-place scan</span>

  <span class="comment">// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__prefixsums.html#ga2b01071da974e996c0ccbe89e5d2d7ce">inclusive_scan</a> </dd>
<dd>
<a class="el" href="group__segmentedprefixsums.html#ga73ac77aacdcc81847c088827b9e85ccf">exclusive_scan_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9e464dc32ccff03b66e7d810634c9a26"></a><!-- doxytag: member="thrust::inclusive_scan_by_key" ref="ga9e464dc32ccff03b66e7d810634c9a26" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::inclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>inclusive_scan_by_key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.</p>
<p>This version of <code>inclusive_scan_by_key</code> assumes <code><a class="el" href="structthrust_1_1equal__to.html">equal_to</a></code> as the binary predicate used to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>*i == *(i+1)</code>, and belong to different segments otherwise.</p>
<p>This version of <code>inclusive_scan_by_key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the output sequence.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator2's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>binary_op(x,y)</code> is defined.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>inclusive_scan_by_key</code> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="scan_8h.html" title="Functions for computing prefix sums.">thrust/scan.h</a>&gt;</span>
  
  <span class="keywordtype">int</span> data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
  <span class="keywordtype">int</span> keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};

  <a class="code" href="group__segmentedprefixsums.html#ga9e464dc32ccff03b66e7d810634c9a26">thrust::inclusive_scan_by_key</a>(keys, keys + 10, vals, vals); <span class="comment">// in-place scan</span>

  <span class="comment">// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__prefixsums.html#ga2b01071da974e996c0ccbe89e5d2d7ce">inclusive_scan</a> </dd>
<dd>
<a class="el" href="group__segmentedprefixsums.html#ga73ac77aacdcc81847c088827b9e85ccf">exclusive_scan_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga05d4b099d9afea2762777bf85a3316de"></a><!-- doxytag: member="thrust::inclusive_scan_by_key" ref="ga05d4b099d9afea2762777bf85a3316de" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred, AssociativeOperator binary_op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryPredicate , typename AssociativeOperator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::inclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssociativeOperator&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>inclusive_scan_by_key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.</p>
<p>This version of <code>inclusive_scan_by_key</code> uses the binary predicate <code>pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary_pred(*i, *(i+1))</code> is true, and belong to different segments otherwise.</p>
<p>This version of <code>inclusive_scan_by_key</code> uses the associative operator <code>binary_op</code> to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>The binary predicate used to determine equality of keys. </td></tr>
    <tr><td class="paramname">binary_op</td><td>The associatve operator used to 'sum' values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the output sequence.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator2's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>binary_op(x,y)</code> is defined. </td></tr>
    <tr><td class="paramname">BinaryPredicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">Binary Predicate</a>. </td></tr>
    <tr><td class="paramname">AssociativeOperator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">Binary Function</a> and <code>AssociativeOperator's</code> <code>result_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>inclusive_scan_by_key</code> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="scan_8h.html" title="Functions for computing prefix sums.">thrust/scan.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="functional_8h.html" title="Function objects and tools for manipulating them.">thrust/functional.h</a>&gt;</span>
  
  <span class="keywordtype">int</span> data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
  <span class="keywordtype">int</span> keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};

  <a class="code" href="structthrust_1_1equal__to.html">thrust::equal_to&lt;int&gt;</a> binary_pred;
  <a class="code" href="structthrust_1_1plus.html">thrust::plus&lt;int&gt;</a>     binary_op;

  <a class="code" href="group__segmentedprefixsums.html#ga9e464dc32ccff03b66e7d810634c9a26">thrust::inclusive_scan_by_key</a>(keys, keys + 10, vals, vals, binary_pred, binary_op); <span class="comment">// in-place scan</span>

  <span class="comment">// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__prefixsums.html#ga2b01071da974e996c0ccbe89e5d2d7ce">inclusive_scan</a> </dd>
<dd>
<a class="el" href="group__segmentedprefixsums.html#ga73ac77aacdcc81847c088827b9e85ccf">exclusive_scan_by_key</a> </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon May 7 2012 15:15:01 for thrust by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
