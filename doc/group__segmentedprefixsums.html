<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>thrust: Segmented Prefix Sums</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">thrust
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Segmented Prefix Sums<div class="ingroups"><a class="el" href="group__prefixsums.html">Prefix Sums</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae84dddc63b198eb91cdf28e19cd2effc"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gae84dddc63b198eb91cdf28e19cd2effc"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#gae84dddc63b198eb91cdf28e19cd2effc">thrust::inclusive_scan_by_key</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result)</td></tr>
<tr class="separator:gae84dddc63b198eb91cdf28e19cd2effc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61acb0c313f9375211f186b86075ce54"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga61acb0c313f9375211f186b86075ce54"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga61acb0c313f9375211f186b86075ce54">thrust::inclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result)</td></tr>
<tr class="separator:ga61acb0c313f9375211f186b86075ce54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga634dbb556c019c0f3a9c641f59dfbd8c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga634dbb556c019c0f3a9c641f59dfbd8c"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga634dbb556c019c0f3a9c641f59dfbd8c">thrust::inclusive_scan_by_key</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred)</td></tr>
<tr class="separator:ga634dbb556c019c0f3a9c641f59dfbd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7294e99fe824bcbb542a3a9567280dd7"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga7294e99fe824bcbb542a3a9567280dd7"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga7294e99fe824bcbb542a3a9567280dd7">thrust::inclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred)</td></tr>
<tr class="separator:ga7294e99fe824bcbb542a3a9567280dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4440c418b802df3a25ff2bf4131d2306"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryPredicate , typename AssociativeOperator &gt; </td></tr>
<tr class="memitem:ga4440c418b802df3a25ff2bf4131d2306"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga4440c418b802df3a25ff2bf4131d2306">thrust::inclusive_scan_by_key</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred, AssociativeOperator binary_op)</td></tr>
<tr class="separator:ga4440c418b802df3a25ff2bf4131d2306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf735a58d04225b29ee16a6cafed7689a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryPredicate , typename AssociativeOperator &gt; </td></tr>
<tr class="memitem:gaf735a58d04225b29ee16a6cafed7689a"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#gaf735a58d04225b29ee16a6cafed7689a">thrust::inclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred, AssociativeOperator binary_op)</td></tr>
<tr class="separator:gaf735a58d04225b29ee16a6cafed7689a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c90ddaacc12dd7daafaa8e18fefb3b9"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga1c90ddaacc12dd7daafaa8e18fefb3b9"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga1c90ddaacc12dd7daafaa8e18fefb3b9">thrust::exclusive_scan_by_key</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result)</td></tr>
<tr class="separator:ga1c90ddaacc12dd7daafaa8e18fefb3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga115ffd69c3e45736772cbdf2b74b9097"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga115ffd69c3e45736772cbdf2b74b9097"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga115ffd69c3e45736772cbdf2b74b9097">thrust::exclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result)</td></tr>
<tr class="separator:ga115ffd69c3e45736772cbdf2b74b9097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49d16201188d12d536eb12aea693db47"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T &gt; </td></tr>
<tr class="memitem:ga49d16201188d12d536eb12aea693db47"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga49d16201188d12d536eb12aea693db47">thrust::exclusive_scan_by_key</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init)</td></tr>
<tr class="separator:ga49d16201188d12d536eb12aea693db47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42d9779f3889cce6a259685b6a170bad"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T &gt; </td></tr>
<tr class="memitem:ga42d9779f3889cce6a259685b6a170bad"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga42d9779f3889cce6a259685b6a170bad">thrust::exclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init)</td></tr>
<tr class="separator:ga42d9779f3889cce6a259685b6a170bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5627b0f2a62d2b1b1f9d29e4fd626987"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga5627b0f2a62d2b1b1f9d29e4fd626987"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga5627b0f2a62d2b1b1f9d29e4fd626987">thrust::exclusive_scan_by_key</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred)</td></tr>
<tr class="separator:ga5627b0f2a62d2b1b1f9d29e4fd626987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3db491d008839bace57f17ce846b1919"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga3db491d008839bace57f17ce846b1919"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga3db491d008839bace57f17ce846b1919">thrust::exclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred)</td></tr>
<tr class="separator:ga3db491d008839bace57f17ce846b1919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd9ada3c6c491c4b676760612168f663"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T , typename BinaryPredicate , typename AssociativeOperator &gt; </td></tr>
<tr class="memitem:gafd9ada3c6c491c4b676760612168f663"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#gafd9ada3c6c491c4b676760612168f663">thrust::exclusive_scan_by_key</a> (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred, AssociativeOperator binary_op)</td></tr>
<tr class="separator:gafd9ada3c6c491c4b676760612168f663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1281d7a3f03c0f0d1c7b185af6896b29"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T , typename BinaryPredicate , typename AssociativeOperator &gt; </td></tr>
<tr class="memitem:ga1281d7a3f03c0f0d1c7b185af6896b29"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga1281d7a3f03c0f0d1c7b185af6896b29">thrust::exclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred, AssociativeOperator binary_op)</td></tr>
<tr class="separator:ga1281d7a3f03c0f0d1c7b185af6896b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1c90ddaacc12dd7daafaa8e18fefb3b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ OutputIterator thrust::exclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>exclusive_scan_by_key</code> computes an exclusive segmented prefix</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the value <code>0</code> to initialize the exclusive scan operation.</p>
<p>This version of <code>exclusive_scan_by_key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.</p>
<p>This version of <code>exclusive_scan_by_key</code> assumes <code><a class="el" href="structthrust_1_1equal__to.html">equal_to</a></code> as the binary predicate used to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1</code> belong to the same segment if <code>*i == *(i+1)</code>, and belong to different segments otherwise.</p>
<p>Refer to the most general form of <code>exclusive_scan_by_key</code> for additional details.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. </dd>
<dd>
<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>exclusive_scan_by_key</code> using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html">thrust/scan.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};</div>
<div class="line"><span class="keywordtype">int</span> vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__segmentedprefixsums.html#ga1c90ddaacc12dd7daafaa8e18fefb3b9">thrust::exclusive_scan_by_key</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, key, key + 10, vals, vals); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// vals is now {0, 1, 2, 0, 1, 0, 0, 1, 2, 3};</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__prefixsums.html#ga0f1b7e1931f6ccd83c67c8cfde7c8144">exclusive_scan</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga115ffd69c3e45736772cbdf2b74b9097"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::exclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>exclusive_scan_by_key</code> computes an exclusive segmented prefix</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the value <code>0</code> to initialize the exclusive scan operation.</p>
<p>This version of <code>exclusive_scan_by_key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.</p>
<p>This version of <code>exclusive_scan_by_key</code> assumes <code><a class="el" href="structthrust_1_1equal__to.html">equal_to</a></code> as the binary predicate used to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1</code> belong to the same segment if <code>*i == *(i+1)</code>, and belong to different segments otherwise.</p>
<p>Refer to the most general form of <code>exclusive_scan_by_key</code> for additional details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. </dd>
<dd>
<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>exclusive_scan_by_key</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html">thrust/scan.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};</div>
<div class="line"><span class="keywordtype">int</span> vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__segmentedprefixsums.html#ga1c90ddaacc12dd7daafaa8e18fefb3b9">thrust::exclusive_scan_by_key</a>(key, key + 10, vals, vals); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// vals is now {0, 1, 2, 0, 1, 0, 0, 1, 2, 3};</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__prefixsums.html#ga0f1b7e1931f6ccd83c67c8cfde7c8144">exclusive_scan</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga49d16201188d12d536eb12aea693db47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ OutputIterator thrust::exclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>exclusive_scan_by_key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the value <code>init</code> to initialize the exclusive scan operation.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence. </td></tr>
    <tr><td class="paramname">init</td><td>The initial of the exclusive sum value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. </dd>
<dd>
<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>exclusive_scan_by_key</code> using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html">thrust/scan.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};</div>
<div class="line"><span class="keywordtype">int</span> vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> init = 5;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__segmentedprefixsums.html#ga1c90ddaacc12dd7daafaa8e18fefb3b9">thrust::exclusive_scan_by_key</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, key, key + 10, vals, vals, init); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__prefixsums.html#ga0f1b7e1931f6ccd83c67c8cfde7c8144">exclusive_scan</a> </dd>
<dd>
<a class="el" href="group__segmentedprefixsums.html#gae84dddc63b198eb91cdf28e19cd2effc">inclusive_scan_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga42d9779f3889cce6a259685b6a170bad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::exclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>exclusive_scan_by_key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the value <code>init</code> to initialize the exclusive scan operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence. </td></tr>
    <tr><td class="paramname">init</td><td>The initial of the exclusive sum value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. </dd>
<dd>
<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>exclusive_scan_by_key</code> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html">thrust/scan.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};</div>
<div class="line"><span class="keywordtype">int</span> vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> init = 5;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__segmentedprefixsums.html#ga1c90ddaacc12dd7daafaa8e18fefb3b9">thrust::exclusive_scan_by_key</a>(key, key + 10, vals, vals, init); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__prefixsums.html#ga0f1b7e1931f6ccd83c67c8cfde7c8144">exclusive_scan</a> </dd>
<dd>
<a class="el" href="group__segmentedprefixsums.html#gae84dddc63b198eb91cdf28e19cd2effc">inclusive_scan_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5627b0f2a62d2b1b1f9d29e4fd626987"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T , typename BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ OutputIterator thrust::exclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>exclusive_scan_by_key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the value <code>init</code> to initialize the exclusive scan operation.</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the binary predicate <code>binary_pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary_pred(*i, *(i+1))</code> is true, and belong to different segments otherwise.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence. </td></tr>
    <tr><td class="paramname">init</td><td>The initial of the exclusive sum value. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>The binary predicate used to determine equality of keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. </dd>
<dd>
<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>exclusive_scan_by_key</code> using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html">thrust/scan.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};</div>
<div class="line"><span class="keywordtype">int</span> vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> init = 5;</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1equal__to.html">thrust::equal_to&lt;int&gt;</a> binary_pred;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__segmentedprefixsums.html#ga1c90ddaacc12dd7daafaa8e18fefb3b9">thrust::exclusive_scan_by_key</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, key, key + 10, vals, vals, init, binary_pred); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__prefixsums.html#ga0f1b7e1931f6ccd83c67c8cfde7c8144">exclusive_scan</a> </dd>
<dd>
<a class="el" href="group__segmentedprefixsums.html#gae84dddc63b198eb91cdf28e19cd2effc">inclusive_scan_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3db491d008839bace57f17ce846b1919"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T , typename BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::exclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>exclusive_scan_by_key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the value <code>init</code> to initialize the exclusive scan operation.</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the binary predicate <code>binary_pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary_pred(*i, *(i+1))</code> is true, and belong to different segments otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence. </td></tr>
    <tr><td class="paramname">init</td><td>The initial of the exclusive sum value. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>The binary predicate used to determine equality of keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. </dd>
<dd>
<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>exclusive_scan_by_key</code> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html">thrust/scan.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};</div>
<div class="line"><span class="keywordtype">int</span> vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> init = 5;</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1equal__to.html">thrust::equal_to&lt;int&gt;</a> binary_pred;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__segmentedprefixsums.html#ga1c90ddaacc12dd7daafaa8e18fefb3b9">thrust::exclusive_scan_by_key</a>(key, key + 10, vals, vals, init, binary_pred); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__prefixsums.html#ga0f1b7e1931f6ccd83c67c8cfde7c8144">exclusive_scan</a> </dd>
<dd>
<a class="el" href="group__segmentedprefixsums.html#gae84dddc63b198eb91cdf28e19cd2effc">inclusive_scan_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafd9ada3c6c491c4b676760612168f663"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T , typename BinaryPredicate , typename AssociativeOperator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ OutputIterator thrust::exclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssociativeOperator&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>exclusive_scan_by_key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the value <code>init</code> to initialize the exclusive scan operation.</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the binary predicate <code>binary_pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary_pred(*i, *(i+1))</code> is true, and belong to different segments otherwise.</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the associative operator <code>binary_op</code> to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence. </td></tr>
    <tr><td class="paramname">init</td><td>The initial of the exclusive sum value. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>The binary predicate used to determine equality of keys. </td></tr>
    <tr><td class="paramname">binary_op</td><td>The associatve operator used to 'sum' values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator2's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>binary_op(x,y)</code> is defined. </td></tr>
    <tr><td class="paramname">T</td><td>is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">BinaryPredicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">Binary Predicate</a>. </td></tr>
    <tr><td class="paramname">AssociativeOperator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">Binary Function</a> and <code>AssociativeOperator's</code> <code>result_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. </dd>
<dd>
<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>exclusive_scan_by_key</code> using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html">thrust/scan.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};</div>
<div class="line"><span class="keywordtype">int</span> vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> init = 5;</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1equal__to.html">thrust::equal_to&lt;int&gt;</a> binary_pred;</div>
<div class="line"><a class="code" href="structthrust_1_1plus.html">thrust::plus&lt;int&gt;</a>     binary_op;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__segmentedprefixsums.html#ga1c90ddaacc12dd7daafaa8e18fefb3b9">thrust::exclusive_scan_by_key</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, key, key + 10, vals, vals, init, binary_pred, binary_op); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__prefixsums.html#ga0f1b7e1931f6ccd83c67c8cfde7c8144">exclusive_scan</a> </dd>
<dd>
<a class="el" href="group__segmentedprefixsums.html#gae84dddc63b198eb91cdf28e19cd2effc">inclusive_scan_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1281d7a3f03c0f0d1c7b185af6896b29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T , typename BinaryPredicate , typename AssociativeOperator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::exclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssociativeOperator&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>exclusive_scan_by_key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the value <code>init</code> to initialize the exclusive scan operation.</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the binary predicate <code>binary_pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary_pred(*i, *(i+1))</code> is true, and belong to different segments otherwise.</p>
<p>This version of <code>exclusive_scan_by_key</code> uses the associative operator <code>binary_op</code> to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence. </td></tr>
    <tr><td class="paramname">init</td><td>The initial of the exclusive sum value. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>The binary predicate used to determine equality of keys. </td></tr>
    <tr><td class="paramname">binary_op</td><td>The associatve operator used to 'sum' values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator2's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>binary_op(x,y)</code> is defined. </td></tr>
    <tr><td class="paramname">T</td><td>is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">BinaryPredicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">Binary Predicate</a>. </td></tr>
    <tr><td class="paramname">AssociativeOperator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">Binary Function</a> and <code>AssociativeOperator's</code> <code>result_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. </dd>
<dd>
<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>exclusive_scan_by_key</code> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html">thrust/scan.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};</div>
<div class="line"><span class="keywordtype">int</span> vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> init = 5;</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1equal__to.html">thrust::equal_to&lt;int&gt;</a> binary_pred;</div>
<div class="line"><a class="code" href="structthrust_1_1plus.html">thrust::plus&lt;int&gt;</a>     binary_op;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__segmentedprefixsums.html#ga1c90ddaacc12dd7daafaa8e18fefb3b9">thrust::exclusive_scan_by_key</a>(key, key + 10, vals, vals, init, binary_pred, binary_op); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__prefixsums.html#ga0f1b7e1931f6ccd83c67c8cfde7c8144">exclusive_scan</a> </dd>
<dd>
<a class="el" href="group__segmentedprefixsums.html#gae84dddc63b198eb91cdf28e19cd2effc">inclusive_scan_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae84dddc63b198eb91cdf28e19cd2effc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ OutputIterator thrust::inclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>inclusive_scan_by_key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.</p>
<p>This version of <code>inclusive_scan_by_key</code> assumes <code><a class="el" href="structthrust_1_1equal__to.html">equal_to</a></code> as the binary predicate used to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>*i == *(i+1)</code>, and belong to different segments otherwise.</p>
<p>This version of <code>inclusive_scan_by_key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator2's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>binary_op(x,y)</code> is defined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. </dd>
<dd>
<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>inclusive_scan_by_key</code> using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html">thrust/scan.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">int data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};</div>
<div class="line"><span class="keywordtype">int</span> keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__segmentedprefixsums.html#gae84dddc63b198eb91cdf28e19cd2effc">thrust::inclusive_scan_by_key</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, keys, keys + 10, vals, vals); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__prefixsums.html#gafb24ad76101263038b0acaddc094d70a">inclusive_scan</a> </dd>
<dd>
<a class="el" href="group__segmentedprefixsums.html#ga1c90ddaacc12dd7daafaa8e18fefb3b9">exclusive_scan_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga61acb0c313f9375211f186b86075ce54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::inclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>inclusive_scan_by_key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.</p>
<p>This version of <code>inclusive_scan_by_key</code> assumes <code><a class="el" href="structthrust_1_1equal__to.html">equal_to</a></code> as the binary predicate used to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>*i == *(i+1)</code>, and belong to different segments otherwise.</p>
<p>This version of <code>inclusive_scan_by_key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator2's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>binary_op(x,y)</code> is defined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. </dd>
<dd>
<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>inclusive_scan_by_key</code> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html">thrust/scan.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};</div>
<div class="line"><span class="keywordtype">int</span> keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__segmentedprefixsums.html#gae84dddc63b198eb91cdf28e19cd2effc">thrust::inclusive_scan_by_key</a>(keys, keys + 10, vals, vals); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__prefixsums.html#gafb24ad76101263038b0acaddc094d70a">inclusive_scan</a> </dd>
<dd>
<a class="el" href="group__segmentedprefixsums.html#ga1c90ddaacc12dd7daafaa8e18fefb3b9">exclusive_scan_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga634dbb556c019c0f3a9c641f59dfbd8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ OutputIterator thrust::inclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>inclusive_scan_by_key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.</p>
<p>This version of <code>inclusive_scan_by_key</code> uses the binary predicate <code>pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary_pred(*i, *(i+1))</code> is true, and belong to different segments otherwise.</p>
<p>This version of <code>inclusive_scan_by_key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>The binary predicate used to determine equality of keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator2's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>binary_op(x,y)</code> is defined. </td></tr>
    <tr><td class="paramname">BinaryPredicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">Binary Predicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. </dd>
<dd>
<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>inclusive_scan_by_key</code> using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html">thrust/scan.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">int data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};</div>
<div class="line"><span class="keywordtype">int</span> keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1equal__to.html">thrust::equal_to&lt;int&gt;</a> binary_pred;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__segmentedprefixsums.html#gae84dddc63b198eb91cdf28e19cd2effc">thrust::inclusive_scan_by_key</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, keys, keys + 10, vals, vals, binary_pred); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__prefixsums.html#gafb24ad76101263038b0acaddc094d70a">inclusive_scan</a> </dd>
<dd>
<a class="el" href="group__segmentedprefixsums.html#ga1c90ddaacc12dd7daafaa8e18fefb3b9">exclusive_scan_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7294e99fe824bcbb542a3a9567280dd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::inclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>inclusive_scan_by_key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.</p>
<p>This version of <code>inclusive_scan_by_key</code> uses the binary predicate <code>pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary_pred(*i, *(i+1))</code> is true, and belong to different segments otherwise.</p>
<p>This version of <code>inclusive_scan_by_key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>The binary predicate used to determine equality of keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator2's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>binary_op(x,y)</code> is defined. </td></tr>
    <tr><td class="paramname">BinaryPredicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">Binary Predicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. </dd>
<dd>
<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>inclusive_scan_by_key</code> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html">thrust/scan.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};</div>
<div class="line"><span class="keywordtype">int</span> keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1equal__to.html">thrust::equal_to&lt;int&gt;</a> binary_pred;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__segmentedprefixsums.html#gae84dddc63b198eb91cdf28e19cd2effc">thrust::inclusive_scan_by_key</a>(keys, keys + 10, vals, vals, binary_pred); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__prefixsums.html#gafb24ad76101263038b0acaddc094d70a">inclusive_scan</a> </dd>
<dd>
<a class="el" href="group__segmentedprefixsums.html#ga1c90ddaacc12dd7daafaa8e18fefb3b9">exclusive_scan_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4440c418b802df3a25ff2bf4131d2306"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPolicy , typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryPredicate , typename AssociativeOperator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ OutputIterator thrust::inclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssociativeOperator&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>inclusive_scan_by_key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.</p>
<p>This version of <code>inclusive_scan_by_key</code> uses the binary predicate <code>pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary_pred(*i, *(i+1))</code> is true, and belong to different segments otherwise.</p>
<p>This version of <code>inclusive_scan_by_key</code> uses the associative operator <code>binary_op</code> to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.</p>
<p>The algorithm's execution is parallelized as determined by <code>exec</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>The execution policy to use for parallelization. </td></tr>
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>The binary predicate used to determine equality of keys. </td></tr>
    <tr><td class="paramname">binary_op</td><td>The associatve operator used to 'sum' values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedPolicy</td><td>The name of the derived execution policy. </td></tr>
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator2's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>binary_op(x,y)</code> is defined. </td></tr>
    <tr><td class="paramname">BinaryPredicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">Binary Predicate</a>. </td></tr>
    <tr><td class="paramname">AssociativeOperator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">Binary Function</a> and <code>AssociativeOperator's</code> <code>result_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. </dd>
<dd>
<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>inclusive_scan_by_key</code> using the <code><a class="el" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a></code> execution policy for parallelization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html">thrust/scan.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="execution__policy_8h.html">thrust/execution_policy.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">int data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};</div>
<div class="line"><span class="keywordtype">int</span> keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1equal__to.html">thrust::equal_to&lt;int&gt;</a> binary_pred;</div>
<div class="line"><a class="code" href="structthrust_1_1plus.html">thrust::plus&lt;int&gt;</a>     binary_op;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__segmentedprefixsums.html#gae84dddc63b198eb91cdf28e19cd2effc">thrust::inclusive_scan_by_key</a>(<a class="code" href="group__execution__policies.html#ga98394c05ebaaac46c17cf0ec970695e0">thrust::host</a>, keys, keys + 10, vals, vals, binary_pred, binary_op); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__prefixsums.html#gafb24ad76101263038b0acaddc094d70a">inclusive_scan</a> </dd>
<dd>
<a class="el" href="group__segmentedprefixsums.html#ga1c90ddaacc12dd7daafaa8e18fefb3b9">exclusive_scan_by_key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf735a58d04225b29ee16a6cafed7689a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryPredicate , typename AssociativeOperator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::inclusive_scan_by_key </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssociativeOperator&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>inclusive_scan_by_key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.</p>
<p>This version of <code>inclusive_scan_by_key</code> uses the binary predicate <code>pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary_pred(*i, *(i+1))</code> is true, and belong to different segments otherwise.</p>
<p>This version of <code>inclusive_scan_by_key</code> uses the associative operator <code>binary_op</code> to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The beginning of the key sequence. </td></tr>
    <tr><td class="paramname">last1</td><td>The end of the key sequence. </td></tr>
    <tr><td class="paramname">first2</td><td>The beginning of the input value sequence. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output value sequence. </td></tr>
    <tr><td class="paramname">binary_pred</td><td>The binary predicate used to determine equality of keys. </td></tr>
    <tr><td class="paramname">binary_op</td><td>The associatve operator used to 'sum' values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator2's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>binary_op(x,y)</code> is defined. </td></tr>
    <tr><td class="paramname">BinaryPredicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">Binary Predicate</a>. </td></tr>
    <tr><td class="paramname">AssociativeOperator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">Binary Function</a> and <code>AssociativeOperator's</code> <code>result_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. </dd>
<dd>
<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.</dd></dl>
<p>The following code snippet demonstrates how to use <code>inclusive_scan_by_key</code> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan_8h.html">thrust/scan.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="functional_8h.html">thrust/functional.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};</div>
<div class="line"><span class="keywordtype">int</span> keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};</div>
<div class="line"></div>
<div class="line"><a class="code" href="structthrust_1_1equal__to.html">thrust::equal_to&lt;int&gt;</a> binary_pred;</div>
<div class="line"><a class="code" href="structthrust_1_1plus.html">thrust::plus&lt;int&gt;</a>     binary_op;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__segmentedprefixsums.html#gae84dddc63b198eb91cdf28e19cd2effc">thrust::inclusive_scan_by_key</a>(keys, keys + 10, vals, vals, binary_pred, binary_op); <span class="comment">// in-place scan</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__prefixsums.html#gafb24ad76101263038b0acaddc094d70a">inclusive_scan</a> </dd>
<dd>
<a class="el" href="group__segmentedprefixsums.html#ga1c90ddaacc12dd7daafaa8e18fefb3b9">exclusive_scan_by_key</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 2 2015 13:21:30 for thrust by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
